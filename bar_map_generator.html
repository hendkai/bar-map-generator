<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BAR Map Generator</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #1e3c72, #2a5298);
            color: white;
            min-height: 100vh;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 30px;
            backdrop-filter: blur(10px);
        }
        
        h1 {
            text-align: center;
            margin-bottom: 30px;
            font-size: 2.5em;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }
        
        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .control-group {
            background: rgba(255, 255, 255, 0.1);
            padding: 20px;
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .control-group h3 {
            margin-top: 0;
            color: #ffd700;
            border-bottom: 2px solid #ffd700;
            padding-bottom: 10px;
        }
        
        label {
            display: block;
            margin: 15px 0 5px 0;
            font-weight: bold;
        }
        
        input[type="range"] {
            width: 100%;
            margin: 5px 0;
        }
        
        input[type="number"], input[type="text"], select, input[type="file"] {
            width: 100%;
            padding: 8px;
            border: none;
            border-radius: 5px;
            background: rgba(255, 255, 255, 0.9);
            color: #333;
        }

        textarea {
            width: 100%;
            padding: 8px;
            border: none;
            border-radius: 5px;
            background: rgba(255, 255, 255, 0.9);
            color: #333;
            resize: vertical;
            min-height: 80px;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        button {
            background: linear-gradient(45deg, #ff6b6b, #ff8e53);
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            transition: transform 0.2s;
            margin: 10px;
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(255, 107, 107, 0.4);
        }
        
        .button-container {
            text-align: center;
            margin: 30px 0;
        }
        
        .canvas-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 30px;
            margin-top: 30px;
        }
        
        .canvas-wrapper {
            text-align: center;
            background: rgba(255, 255, 255, 0.1);
            padding: 20px;
            border-radius: 10px;
        }
        
        canvas {
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 10px;
            max-width: 100%;
            height: auto;
        }
        
        .canvas-wrapper h3 {
            color: #ffd700;
            margin-bottom: 15px;
        }
        
        .info {
            background: rgba(255, 255, 255, 0.1);
            padding: 20px;
            border-radius: 10px;
            margin-top: 20px;
            border-left: 4px solid #ffd700;
        }
        
        .download-section {
            margin-top: 30px;
            text-align: center;
            background: rgba(255, 255, 255, 0.1);
            padding: 20px;
            border-radius: 10px;
        }
        
        .value-display {
            display: inline-block;
            background: rgba(255, 255, 255, 0.2);
            padding: 2px 8px;
            border-radius: 4px;
            margin-left: 10px;
            font-weight: bold;
            color: #ffd700;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üó∫Ô∏è Beyond All Reason Map Generator</h1>
        
        <div class="controls">
            <div class="control-group">
                <h3>Map Basics</h3>
                <label>Map Size:
                    <select id="mapSize">
                        <option value="512">512x512 (Small)</option>
                        <option value="1024" selected>1024x1024 (Medium)</option>
                        <option value="2048">2048x2048 (Large)</option>
                    </select>
                </label>
                
                <label>Terrain Type:
                    <select id="terrainType">
                        <option value="continental">Continental</option>
                        <option value="islands">Islands</option>
                        <option value="canyon">Canyon</option>
                        <option value="hills">Hills</option>
                        <option value="flat">Flat</option>
                    </select>
                </label>
                
                <label>Player Count:
                    <select id="playerCount">
                        <option value="2">2 Players</option>
                        <option value="4" selected>4 Players</option>
                        <option value="6">6 Players</option>
                        <option value="8">8 Players</option>
                    </select>
                </label>
            </div>
            
            <div class="control-group">
                <h3>Terrain Parameters</h3>
                <label>Noise Strength: <span class="value-display" id="noiseValue">0.5</span>
                    <input type="range" id="noiseStrength" min="0.1" max="1.0" step="0.1" value="0.5">
                </label>
                
                <label>Height Variation: <span class="value-display" id="heightValue">128</span>
                    <input type="range" id="heightVariation" min="50" max="255" step="5" value="128">
                </label>
                
                <label>Water Level: <span class="value-display" id="waterValue">64</span>
                    <input type="range" id="waterLevel" min="0" max="128" step="4" value="64">
                </label>
                
                <label>Smoothing: <span class="value-display" id="smoothValue">2</span>
                    <input type="range" id="smoothing" min="0" max="5" step="1" value="2">
                </label>
            </div>
            
            <div class="control-group">
                <h3>Resources</h3>
                <label>Metal Spots: <span class="value-display" id="metalValue">20</span>
                    <input type="range" id="metalSpots" min="10" max="50" step="2" value="20">
                </label>

                <label>Metal Strength: <span class="value-display" id="metalStrengthValue">2.0</span>
                    <input type="range" id="metalStrength" min="1.0" max="5.0" step="0.1" value="2.0">
                </label>

                <label>Geo Spots: <span class="value-display" id="geoValue">4</span>
                    <input type="range" id="geoSpots" min="2" max="12" step="1" value="4">
                </label>

                <label style="margin-top: 15px;">
                    <input type="checkbox" id="showTerritories" checked style="width: auto; margin-right: 8px;">
                    Show Territory Overlay (Voronoi Regions)
                </label>
            </div>

            <div class="control-group">
                <h3>Map Metadata</h3>
                <label>Creator Name:
                    <input type="text" id="creatorName" placeholder="Enter your name" maxlength="100">
                </label>

                <label>Description:
                    <textarea id="mapDescription" placeholder="Enter a description for this map" maxlength="500"></textarea>
                </label>
            </div>
        </div>
        
        <div class="button-container">
            <button onclick="generateMap()">üé≤ Generate Map (Preview Only)</button>
            <button onclick="randomizeSettings()">‚ö° Randomize Settings</button>
        </div>
        
        <div class="canvas-container">
            <div class="canvas-wrapper">
                <h3>Heightmap</h3>
                <canvas id="heightmapCanvas" width="512" height="512"></canvas>
            </div>
            
            <div class="canvas-wrapper">
                <h3>Texture Map</h3>
                <canvas id="textureCanvas" width="512" height="512"></canvas>
            </div>
            
            <div class="canvas-wrapper">
                <h3>Resource Map</h3>
                <canvas id="resourceCanvas" width="512" height="512"></canvas>
            </div>
        </div>

        <div class="canvas-container">
            <div class="canvas-wrapper">
                <h3>3D Terrain Preview</h3>
                <canvas id="terrain3dCanvas" width="512" height="512"></canvas>
                <div style="margin-top: 15px; text-align: center;">
                    <button onclick="resetCameraView()">üîÑ Reset View</button>
                    <button onclick="toggleWireframe()">üìê Toggle Wireframe</button>
                    <button onclick="zoomIn()">üîç+ Zoom In</button>
                    <button onclick="zoomOut()">üîç- Zoom Out</button>
                </div>
            </div>
        </div>

        <div class="download-section">
            <h3>üì• Export for BAR</h3>
            <button onclick="downloadCompleteMapPackage()">üéØ Download Complete BAR Map Package (.zip)</button>
            <br>
            <p style="margin: 15px 0; font-size: 14px; opacity: 0.8;">
                ‚ö†Ô∏è <strong>Experimental:</strong> Generates all assets + automatic build script. May not work reliably yet!
            </p>
            <hr style="margin: 20px 0; border: 1px solid rgba(255,255,255,0.2);">
            <h4>Individual Files:</h4>
            <button onclick="downloadHeightmap()">Heightmap (.png)</button>
            <button onclick="downloadMetalmap()">Metalmap (.bmp)</button>
            <button onclick="downloadTexture()">Texture (.bmp)</button>
            <button onclick="downloadNormalmap()">Normalmap (.png)</button>
            <button onclick="downloadSpecularmap()">Specularmap (.png)</button>
            <button onclick="downloadMinimap()">Minimap (.png)</button>
            <button onclick="downloadConfig()">mapinfo.lua</button>
        </div>

        <div class="download-section">
            <h3>‚öôÔ∏è Configuration Import/Export</h3>
            <p style="margin: 15px 0; font-size: 14px; opacity: 0.8;">
                Save and share your map configurations as JSON files or copy-pasteable text strings.
            </p>

            <!-- Export Section -->
            <div style="margin-bottom: 20px;">
                <strong>Export Configuration:</strong><br>
                <button onclick="exportConfigJSON()">üìÑ Export Config (JSON)</button>
                <button onclick="exportConfigText()">üìã Copy Config (Text)</button>
            </div>

            <!-- Import from File Section -->
            <div style="margin-bottom: 20px;">
                <strong>Import from File:</strong><br>
                <input type="file" id="configFileInput" accept=".json" style="margin-bottom: 10px;">
                <button onclick="importConfigFromFile()">üìÅ Import from File</button>
            </div>

            <!-- Import from Text Section -->
            <div>
                <strong>Import from Text:</strong><br>
                <textarea id="configTextInput" placeholder="Paste your configuration string here..." style="margin-bottom: 10px;"></textarea>
                <button onclick="importConfigFromText()">üìù Import from Text</button>
            </div>
        </div>

        <div class="info">
            <h3>üí° Usage Instructions</h3>
            <p><strong>‚ö†Ô∏è Development Status:</strong> This tool is experimental and may not work reliably yet.</p>
            <p><strong>1. Generate Map:</strong> Adjust parameters to your liking and click "Generate Map".</p>
            <p><strong>2. Download Package:</strong> Click "Download Complete BAR Map Package" (experimental).</p>
            <p><strong>3. Run Build Script:</strong> Extract the ZIP and run the included build script.</p>
            <p><strong>4. Install Map:</strong> Copy the generated .sd7 file to your BAR maps folder.</p>
            <p><strong>Requirements:</strong> Python 3.x and Spring Map Tools (PyMapConv) - downloaded automatically if not present.</p>
        </div>
    </div>

    <script>
        let heightmapData, textureData, resourceData;
        let mapConfig = {};

        // WebGL 3D Terrain Preview Variables
        let gl;
        let shaderProgram;
        let terrainBuffers;
        let startPositionBuffers;
        let metalSpotBuffers;
        let geoSpotBuffers;
        let markerShaderProgram;

        // Initialize WebGL context and shaders
        function initWebGL() {
            const canvas = document.getElementById('terrain3dCanvas');
            gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');

            if (!gl) {
                console.error('WebGL not supported');
                return false;
            }

            // Enable OES_element_index_uint extension for large mesh support
            // Required for UNSIGNED_INT indices (> 65535 vertices)
            const ext = gl.getExtension('OES_element_index_uint');
            if (!ext) {
                console.warn('OES_element_index_uint extension not available - large maps may not render correctly');
            }

            // Create shader program
            shaderProgram = createShaderProgram();
            if (!shaderProgram) {
                console.error('Failed to create shader program');
                return false;
            }

            gl.useProgram(shaderProgram);

            // Get attribute and uniform locations
            shaderProgram.vertexPositionAttribute = gl.getAttribLocation(shaderProgram, 'aVertexPosition');
            shaderProgram.vertexHeightAttribute = gl.getAttribLocation(shaderProgram, 'aVertexHeight');
            shaderProgram.pMatrixUniform = gl.getUniformLocation(shaderProgram, 'uPMatrix');
            shaderProgram.mvMatrixUniform = gl.getUniformLocation(shaderProgram, 'uMVMatrix');
            shaderProgram.waterLevelUniform = gl.getUniformLocation(shaderProgram, 'uWaterLevel');

            gl.enableVertexAttribArray(shaderProgram.vertexPositionAttribute);
            gl.enableVertexAttribArray(shaderProgram.vertexHeightAttribute);

            // Create marker shader program
            markerShaderProgram = createMarkerShaderProgram();
            if (!markerShaderProgram) {
                console.error('Failed to create marker shader program');
                return false;
            }

            // Get marker shader attribute and uniform locations
            markerShaderProgram.vertexPositionAttribute = gl.getAttribLocation(markerShaderProgram, 'aVertexPosition');
            markerShaderProgram.pMatrixUniform = gl.getUniformLocation(markerShaderProgram, 'uPMatrix');
            markerShaderProgram.mvMatrixUniform = gl.getUniformLocation(markerShaderProgram, 'uMVMatrix');
            markerShaderProgram.colorUniform = gl.getUniformLocation(markerShaderProgram, 'uColor');

            gl.enableVertexAttribArray(markerShaderProgram.vertexPositionAttribute);

            // Set up WebGL state
            gl.clearColor(0.0, 0.0, 0.0, 1.0);
            gl.enable(gl.DEPTH_TEST);

            console.log('WebGL initialized successfully');
            return true;
        }

        function createShaderProgram() {
            const vertexShaderSource = `
                attribute vec3 aVertexPosition;
                attribute float aVertexHeight;

                uniform mat4 uPMatrix;
                uniform mat4 uMVMatrix;

                varying float vHeight;

                void main() {
                    gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
                    vHeight = aVertexHeight;
                }
            `;

            const fragmentShaderSource = `
                precision mediump float;

                varying float vHeight;
                uniform float uWaterLevel;

                void main() {
                    vec3 color;

                    // Height-based terrain coloring (matches generateTextureMap pattern)
                    // Water: RGB(30, 100, 200) -> vec3(0.118, 0.392, 0.784)
                    if (vHeight < uWaterLevel) {
                        color = vec3(0.118, 0.392, 0.784);
                    }
                    // Sand/Beach: RGB(255, 230, 150) -> vec3(1.0, 0.902, 0.588)
                    else if (vHeight < uWaterLevel + 20.0) {
                        color = vec3(1.0, 0.902, 0.588);
                    }
                    // Grass: RGB(50, 150, 50) -> vec3(0.196, 0.588, 0.196)
                    else if (vHeight < uWaterLevel + 80.0) {
                        color = vec3(0.196, 0.588, 0.196);
                    }
                    // Rock: RGB(120, 120, 120) -> vec3(0.471, 0.471, 0.471)
                    else if (vHeight < uWaterLevel + 120.0) {
                        color = vec3(0.471, 0.471, 0.471);
                    }
                    // Snow: RGB(255, 255, 255) -> vec3(1.0, 1.0, 1.0)
                    else {
                        color = vec3(1.0, 1.0, 1.0);
                    }

                    gl_FragColor = vec4(color, 1.0);
                }
            `;

            const vertexShader = compileShader(gl.VERTEX_SHADER, vertexShaderSource);
            const fragmentShader = compileShader(gl.FRAGMENT_SHADER, fragmentShaderSource);

            if (!vertexShader || !fragmentShader) {
                return null;
            }

            const program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);

            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                console.error('Shader program link failed:', gl.getProgramInfoLog(program));
                return null;
            }

            return program;
        }

        function compileShader(type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);

            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('Shader compile error:', gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }

            return shader;
        }

        // Create shader program for solid-color markers
        function createMarkerShaderProgram() {
            const vertexShaderSource = `
                attribute vec3 aVertexPosition;

                uniform mat4 uPMatrix;
                uniform mat4 uMVMatrix;

                void main() {
                    gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
                }
            `;

            const fragmentShaderSource = `
                precision mediump float;
                uniform vec3 uColor;

                void main() {
                    gl_FragColor = vec4(uColor, 1.0);
                }
            `;

            const vertexShader = compileShader(gl.VERTEX_SHADER, vertexShaderSource);
            const fragmentShader = compileShader(gl.FRAGMENT_SHADER, fragmentShaderSource);

            if (!vertexShader || !fragmentShader) {
                return null;
            }

            const program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);

            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                console.error('Marker shader program link failed:', gl.getProgramInfoLog(program));
                return null;
            }

            return program;
        }

        // Generate terrain mesh geometry from heightmap
        function generateTerrainMesh(heightmap, size) {
            const vertices = [];
            const heights = [];
            const indices = [];

            // Optimize mesh resolution for large maps to maintain acceptable frame rate
            // Large maps with full resolution would have too many vertices for real-time rendering
            let stride = 1;
            if (size >= 2048) {
                stride = 4; // 2048x2048 -> 512x512 mesh (262k vertices)
            } else if (size >= 1024) {
                stride = 2; // 1024x1024 -> 512x512 mesh (262k vertices)
            }
            // 512x512 and smaller use full resolution (262k vertices or less)

            const meshSize = Math.floor((size - 1) / stride) + 1;
            const scaleXZ = 1.0 / size;
            const scaleY = 1.0 / 255.0;

            // Generate vertices with stride-based sampling
            for (let z = 0; z < size; z += stride) {
                for (let x = 0; x < size; x += stride) {
                    const index = z * size + x;
                    const height = heightmap[index];

                    // Position: x, y (height), z
                    // Center the terrain around (0, 0, 0)
                    const posX = (x / (size - 1)) * 2.0 - 1.0;
                    const posY = height * scaleY;
                    const posZ = (z / (size - 1)) * 2.0 - 1.0;

                    vertices.push(posX, posY, posZ);
                    heights.push(height);
                }
            }

            // Generate indices for triangles
            // Note: meshSize is the number of vertices per row in the simplified mesh
            for (let z = 0; z < meshSize - 1; z++) {
                for (let x = 0; x < meshSize - 1; x++) {
                    const topLeft = z * meshSize + x;
                    const topRight = topLeft + 1;
                    const bottomLeft = (z + 1) * meshSize + x;
                    const bottomRight = bottomLeft + 1;

                    // First triangle (top-left, bottom-left, top-right)
                    indices.push(topLeft, bottomLeft, topRight);

                    // Second triangle (top-right, bottom-left, bottom-right)
                    indices.push(topRight, bottomLeft, bottomRight);
                }
            }

            return {
                vertices: new Float32Array(vertices),
                heights: new Float32Array(heights),
                indices: new Uint32Array(indices),
                vertexCount: meshSize * meshSize,
                indexCount: indices.length,
                meshSize: meshSize
            };
        }

        // Create WebGL buffers and upload mesh data
        function uploadMeshDataToBuffers(mesh) {
            if (!gl) {
                console.error('WebGL context not initialized');
                return null;
            }

            // Create and populate vertex position buffer
            const positionBuffer = gl.createBuffer();
            if (!positionBuffer) {
                console.error('Failed to create position buffer');
                return null;
            }
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, mesh.vertices, gl.STATIC_DRAW);

            // Create and populate vertex height buffer
            const heightBuffer = gl.createBuffer();
            if (!heightBuffer) {
                console.error('Failed to create height buffer');
                return null;
            }
            gl.bindBuffer(gl.ARRAY_BUFFER, heightBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, mesh.heights, gl.STATIC_DRAW);

            // Create and populate index buffer
            const indexBuffer = gl.createBuffer();
            if (!indexBuffer) {
                console.error('Failed to create index buffer');
                return null;
            }
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, mesh.indices, gl.STATIC_DRAW);

            const buffers = {
                position: positionBuffer,
                height: heightBuffer,
                indices: indexBuffer,
                vertexCount: mesh.vertexCount,
                indexCount: mesh.indexCount
            };

            console.log('Mesh data uploaded to WebGL buffers:', {
                vertices: mesh.vertexCount,
                indices: mesh.indexCount
            });

            return buffers;
        }

        // Generate cone geometry for a start position marker
        function generateConeMesh(x, y, z, radius, height) {
            const vertices = [];
            const indices = [];
            const segments = 16;

            // Cone tip at top
            vertices.push(x, y + height, z);

            // Base vertices
            for (let i = 0; i < segments; i++) {
                const angle = (i / segments) * Math.PI * 2;
                const px = x + Math.cos(angle) * radius;
                const pz = z + Math.sin(angle) * radius;
                vertices.push(px, y, pz);
            }

            // Generate triangles
            for (let i = 0; i < segments; i++) {
                const next = (i + 1) % segments;
                indices.push(0, i + 1, next + 1);
            }

            return {
                vertices: new Float32Array(vertices),
                indices: new Uint16Array(indices),
                vertexCount: vertices.length / 3,
                indexCount: indices.length
            };
        }

        function generateSphereMesh(x, y, z, radius) {
            const vertices = [];
            const indices = [];
            const latSegments = 8;
            const lonSegments = 16;

            // Generate vertices
            for (let lat = 0; lat <= latSegments; lat++) {
                const theta = (lat * Math.PI) / latSegments;
                const sinTheta = Math.sin(theta);
                const cosTheta = Math.cos(theta);

                for (let lon = 0; lon <= lonSegments; lon++) {
                    const phi = (lon * 2 * Math.PI) / lonSegments;
                    const sinPhi = Math.sin(phi);
                    const cosPhi = Math.cos(phi);

                    const px = x + radius * sinTheta * cosPhi;
                    const py = y + radius * cosTheta;
                    const pz = z + radius * sinTheta * sinPhi;

                    vertices.push(px, py, pz);
                }
            }

            // Generate indices
            for (let lat = 0; lat < latSegments; lat++) {
                for (let lon = 0; lon < lonSegments; lon++) {
                    const first = lat * (lonSegments + 1) + lon;
                    const second = first + lonSegments + 1;

                    indices.push(first, second, first + 1);
                    indices.push(second, second + 1, first + 1);
                }
            }

            return {
                vertices: new Float32Array(vertices),
                indices: new Uint16Array(indices),
                vertexCount: vertices.length / 3,
                indexCount: indices.length
            };
        }

        // Generate marker meshes for start positions (green cones)
        function generateStartPositionMeshes(startPositions, heightmap, size, waterLevel) {
            const allVertices = [];
            const allIndices = [];
            let totalVertices = 0;
            let totalIndices = 0;

            const markerRadius = size * 0.01;
            const markerHeight = size * 0.02;

            startPositions.forEach((pos) => {
                const height = heightmap[pos.y * size + pos.x];
                const normalizedHeight = height / 255.0;

                // Convert map coordinates to terrain coordinates
                const terrainX = (pos.x / (size - 1)) * 2.0 - 1.0;
                const terrainZ = (pos.y / (size - 1)) * 2.0 - 1.0;
                const terrainY = normalizedHeight;

                const cone = generateConeMesh(
                    terrainX,
                    terrainY,
                    terrainZ,
                    markerRadius,
                    markerHeight
                );

                const vertexOffset = totalVertices;

                for (let i = 0; i < cone.vertices.length; i++) {
                    allVertices.push(cone.vertices[i]);
                }

                for (let i = 0; i < cone.indices.length; i++) {
                    allIndices.push(cone.indices[i] + vertexOffset);
                }

                totalVertices += cone.vertexCount;
                totalIndices += cone.indexCount;
            });

            return {
                vertices: new Float32Array(allVertices),
                indices: new Uint16Array(allIndices),
                vertexCount: totalVertices,
                indexCount: totalIndices
            };
        }

        // Generate marker meshes for metal spots (yellow spheres)
        function generateMetalSpotMeshes(metalSpots, heightmap, size, waterLevel) {
            const allVertices = [];
            const allIndices = [];
            let totalVertices = 0;
            let totalIndices = 0;

            const sphereRadius = size * 0.008;

            metalSpots.forEach((pos) => {
                const height = heightmap[pos.y * size + pos.x];
                const normalizedHeight = height / 255.0;

                // Convert map coordinates to terrain coordinates
                const terrainX = (pos.x / (size - 1)) * 2.0 - 1.0;
                const terrainZ = (pos.y / (size - 1)) * 2.0 - 1.0;
                const terrainY = normalizedHeight + sphereRadius;

                const sphere = generateSphereMesh(
                    terrainX,
                    terrainY,
                    terrainZ,
                    sphereRadius
                );

                const vertexOffset = totalVertices;

                for (let i = 0; i < sphere.vertices.length; i++) {
                    allVertices.push(sphere.vertices[i]);
                }

                for (let i = 0; i < sphere.indices.length; i++) {
                    allIndices.push(sphere.indices[i] + vertexOffset);
                }

                totalVertices += sphere.vertexCount;
                totalIndices += sphere.indexCount;
            });

            return {
                vertices: new Float32Array(allVertices),
                indices: new Uint16Array(allIndices),
                vertexCount: totalVertices,
                indexCount: totalIndices
            };
        }

        // Generate marker meshes for geothermal spots (red spheres)
        function generateGeoSpotMeshes(geoSpots, heightmap, size, waterLevel) {
            const allVertices = [];
            const allIndices = [];
            let totalVertices = 0;
            let totalIndices = 0;

            const sphereRadius = size * 0.008;

            geoSpots.forEach((pos) => {
                const height = heightmap[pos.y * size + pos.x];
                const normalizedHeight = height / 255.0;

                // Convert map coordinates to terrain coordinates
                const terrainX = (pos.x / (size - 1)) * 2.0 - 1.0;
                const terrainZ = (pos.y / (size - 1)) * 2.0 - 1.0;
                const terrainY = normalizedHeight + sphereRadius;

                const sphere = generateSphereMesh(
                    terrainX,
                    terrainY,
                    terrainZ,
                    sphereRadius
                );

                const vertexOffset = totalVertices;

                for (let i = 0; i < sphere.vertices.length; i++) {
                    allVertices.push(sphere.vertices[i]);
                }

                for (let i = 0; i < sphere.indices.length; i++) {
                    allIndices.push(sphere.indices[i] + vertexOffset);
                }

                totalVertices += sphere.vertexCount;
                totalIndices += sphere.indexCount;
            });

            return {
                vertices: new Float32Array(allVertices),
                indices: new Uint16Array(allIndices),
                vertexCount: totalVertices,
                indexCount: totalIndices
            };
        }

        // Upload marker data to WebGL buffers
        function uploadMarkerDataToBuffers(mesh) {
            if (!gl) {
                console.error('WebGL context not initialized');
                return null;
            }

            const positionBuffer = gl.createBuffer();
            if (!positionBuffer) {
                console.error('Failed to create marker position buffer');
                return null;
            }
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, mesh.vertices, gl.STATIC_DRAW);

            const indexBuffer = gl.createBuffer();
            if (!indexBuffer) {
                console.error('Failed to create marker index buffer');
                return null;
            }
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, mesh.indices, gl.STATIC_DRAW);

            const buffers = {
                position: positionBuffer,
                indices: indexBuffer,
                indexCount: mesh.indexCount
            };

            console.log('Marker data uploaded to WebGL buffers:', {
                indices: mesh.indexCount
            });

            return buffers;
        }

        // Simple Matrix4 math utilities for WebGL
        const mat4 = {
            create: function() {
                return new Float32Array([
                    1, 0, 0, 0,
                    0, 1, 0, 0,
                    0, 0, 1, 0,
                    0, 0, 0, 1
                ]);
            },

            perspective: function(out, fovy, aspect, near, far) {
                const f = 1.0 / Math.tan(fovy / 2);
                const nf = 1 / (near - far);
                out[0] = f / aspect;
                out[1] = 0;
                out[2] = 0;
                out[3] = 0;
                out[4] = 0;
                out[5] = f;
                out[6] = 0;
                out[7] = 0;
                out[8] = 0;
                out[9] = 0;
                out[10] = (far + near) * nf;
                out[11] = -1;
                out[12] = 0;
                out[13] = 0;
                out[14] = (2 * far * near) * nf;
                out[15] = 0;
                return out;
            },

            translate: function(out, a, v) {
                const x = v[0], y = v[1], z = v[2];
                out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
                out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
                out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
                out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
                if (out !== a) {
                    for (let i = 0; i < 12; i++) {
                        out[i] = a[i];
                    }
                }
                return out;
            },

            rotate: function(out, a, rad, axis) {
                let x = axis[0], y = axis[1], z = axis[2];
                let len = Math.sqrt(x * x + y * y + z * z);
                if (len < 0.00001) return null;
                len = 1 / len;
                x *= len;
                y *= len;
                z *= len;
                const s = Math.sin(rad);
                const c = Math.cos(rad);
                const t = 1 - c;
                const a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
                const a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
                const a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
                const b00 = x * x * t + c;
                const b01 = y * x * t + z * s;
                const b02 = z * x * t - y * s;
                const b10 = x * y * t - z * s;
                const b11 = y * y * t + c;
                const b12 = z * y * t + x * s;
                const b20 = x * z * t + y * s;
                const b21 = y * z * t - x * s;
                const b22 = z * z * t + c;
                out[0] = a00 * b00 + a10 * b01 + a20 * b02;
                out[1] = a01 * b00 + a11 * b01 + a21 * b02;
                out[2] = a02 * b00 + a12 * b01 + a22 * b02;
                out[3] = a03 * b00 + a13 * b01 + a23 * b02;
                out[4] = a00 * b10 + a10 * b11 + a20 * b12;
                out[5] = a01 * b10 + a11 * b11 + a21 * b12;
                out[6] = a02 * b10 + a12 * b11 + a22 * b12;
                out[7] = a03 * b10 + a13 * b11 + a23 * b12;
                out[8] = a00 * b20 + a10 * b21 + a20 * b22;
                out[9] = a01 * b20 + a11 * b21 + a21 * b22;
                out[10] = a02 * b20 + a12 * b21 + a22 * b22;
                out[11] = a03 * b20 + a13 * b21 + a23 * b22;
                return out;
            },

            identity: function(out) {
                out[0] = 1; out[1] = 0; out[2] = 0; out[3] = 0;
                out[4] = 0; out[5] = 1; out[6] = 0; out[7] = 0;
                out[8] = 0; out[9] = 0; out[10] = 1; out[11] = 0;
                out[12] = 0; out[13] = 0; out[14] = 0; out[15] = 1;
                return out;
            }
        };

        // Camera state for 3D terrain preview
        let cameraState = {
            rotationX: 45,
            rotationY: 45,
            zoom: 2.0,
            panX: 0,
            panY: 0
        };

        // Wireframe mode for 3D terrain preview
        let wireframeMode = false;

        // Mouse drag state for camera rotation and panning
        let isDragging = false;
        let isPanning = false;
        let lastMouseX = 0;
        let lastMouseY = 0;

        // Initialize camera controls
        function initCameraControls() {
            const canvas = document.getElementById('terrain3dCanvas');

            canvas.addEventListener('mousedown', function(e) {
                isDragging = true;
                // Check for right-click (button 2) or shift key for panning
                isPanning = (e.button === 2) || e.shiftKey;
                lastMouseX = e.clientX;
                lastMouseY = e.clientY;
            });

            canvas.addEventListener('mousemove', function(e) {
                if (!isDragging) return;

                const deltaX = e.clientX - lastMouseX;
                const deltaY = e.clientY - lastMouseY;

                if (isPanning) {
                    // Update pan position (sensitivity: 0.5 units per pixel)
                    const panSpeed = 0.5;
                    cameraState.panX += deltaX * panSpeed;
                    cameraState.panY -= deltaY * panSpeed;
                } else {
                    // Update rotation angles (sensitivity: 0.5 degrees per pixel)
                    cameraState.rotationY += deltaX * 0.5;
                    cameraState.rotationX += deltaY * 0.5;

                    // Clamp vertical rotation to prevent flipping
                    cameraState.rotationX = Math.max(10, Math.min(90, cameraState.rotationX));
                }

                lastMouseX = e.clientX;
                lastMouseY = e.clientY;

                // Request redraw
                requestAnimationFrame(drawScene);
            });

            canvas.addEventListener('mouseup', function() {
                isDragging = false;
                isPanning = false;
            });

            canvas.addEventListener('mouseleave', function() {
                isDragging = false;
                isPanning = false;
            });

            // Prevent context menu on right-click
            canvas.addEventListener('contextmenu', function(e) {
                e.preventDefault();
                return false;
            });

            // Touch support for mobile devices
            canvas.addEventListener('touchstart', function(e) {
                if (e.touches.length === 1) {
                    isDragging = true;
                    lastMouseX = e.touches[0].clientX;
                    lastMouseY = e.touches[0].clientY;
                    e.preventDefault();
                }
            });

            canvas.addEventListener('touchmove', function(e) {
                if (!isDragging || e.touches.length !== 1) return;

                const deltaX = e.touches[0].clientX - lastMouseX;
                const deltaY = e.touches[0].clientY - lastMouseY;

                cameraState.rotationY += deltaX * 0.5;
                cameraState.rotationX += deltaY * 0.5;
                cameraState.rotationX = Math.max(10, Math.min(90, cameraState.rotationX));

                lastMouseX = e.touches[0].clientX;
                lastMouseY = e.touches[0].clientY;

                requestAnimationFrame(drawScene);
                e.preventDefault();
            });

            canvas.addEventListener('touchend', function() {
                isDragging = false;
            });

            // Mouse wheel zoom control
            canvas.addEventListener('wheel', function(e) {
                e.preventDefault();

                // Zoom sensitivity: adjust zoom based on wheel delta
                const zoomSpeed = 0.001;
                cameraState.zoom -= e.deltaY * zoomSpeed;

                // Clamp zoom to reasonable limits (0.5x to 5.0x)
                cameraState.zoom = Math.max(0.5, Math.min(5.0, cameraState.zoom));

                // Request redraw
                requestAnimationFrame(drawScene);
            }, { passive: false });
        }

        // Reset 3D camera view to default position
        function resetCameraView() {
            cameraState.rotationX = 45;
            cameraState.rotationY = 45;
            cameraState.zoom = 2.0;
            cameraState.panX = 0;
            cameraState.panY = 0;
            requestAnimationFrame(drawScene);
        }

        // Toggle wireframe rendering mode
        function toggleWireframe() {
            wireframeMode = !wireframeMode;
            requestAnimationFrame(drawScene);
        }

        // Zoom in
        function zoomIn() {
            cameraState.zoom = Math.max(0.5, cameraState.zoom - 0.2);
            requestAnimationFrame(drawScene);
        }

        // Zoom out
        function zoomOut() {
            cameraState.zoom = Math.min(5.0, cameraState.zoom + 0.2);
            requestAnimationFrame(drawScene);
        }

        // Render the 3D terrain scene
        function drawScene() {
            if (!gl || !terrainBuffers) {
                return;
            }

            const canvas = gl.canvas;
            gl.viewport(0, 0, canvas.width, canvas.height);

            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

            const projectionMatrix = mat4.create();
            const modelViewMatrix = mat4.create();

            const aspect = canvas.width / canvas.height;
            mat4.perspective(projectionMatrix, 45 * Math.PI / 180, aspect, 0.1, 1000.0);

            mat4.identity(modelViewMatrix);

            mat4.translate(modelViewMatrix, modelViewMatrix, [cameraState.panX, -cameraState.panY, -mapConfig.size / 64 * cameraState.zoom]);

            mat4.rotate(modelViewMatrix, modelViewMatrix, cameraState.rotationX * Math.PI / 180, [1, 0, 0]);
            mat4.rotate(modelViewMatrix, modelViewMatrix, cameraState.rotationY * Math.PI / 180, [0, 1, 0]);

            mat4.translate(modelViewMatrix, modelViewMatrix, [-mapConfig.size / 128, 0, -mapConfig.size / 128]);

            gl.uniformMatrix4fv(shaderProgram.pMatrixUniform, false, projectionMatrix);
            gl.uniformMatrix4fv(shaderProgram.mvMatrixUniform, false, modelViewMatrix);
            gl.uniform1f(shaderProgram.waterLevelUniform, mapConfig.waterLevel);

            gl.bindBuffer(gl.ARRAY_BUFFER, terrainBuffers.position);
            gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, 3, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ARRAY_BUFFER, terrainBuffers.height);
            gl.vertexAttribPointer(shaderProgram.vertexHeightAttribute, 1, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, terrainBuffers.indices);

            // Use UNSIGNED_INT for large meshes (may exceed 65535 vertices)
            // UNSIGNED_SHORT is insufficient for meshes larger than 256x256
            // Draw in wireframe mode if enabled
            if (wireframeMode) {
                for (let i = 0; i < terrainBuffers.indexCount; i += 3) {
                    gl.drawElements(gl.LINE_LOOP, 3, gl.UNSIGNED_INT, i * 4);
                }
            } else {
                gl.drawElements(gl.TRIANGLES, terrainBuffers.indexCount, gl.UNSIGNED_INT, 0);
            }

            // Draw start position markers (green cones)
            if (startPositionBuffers && markerShaderProgram) {
                gl.useProgram(markerShaderProgram);

                gl.uniformMatrix4fv(markerShaderProgram.pMatrixUniform, false, projectionMatrix);
                gl.uniformMatrix4fv(markerShaderProgram.mvMatrixUniform, false, modelViewMatrix);

                // Green color for start positions (matching 2D preview)
                gl.uniform3f(markerShaderProgram.colorUniform, 0.267, 1.0, 0.267);

                gl.bindBuffer(gl.ARRAY_BUFFER, startPositionBuffers.position);
                gl.vertexAttribPointer(markerShaderProgram.vertexPositionAttribute, 3, gl.FLOAT, false, 0, 0);

                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, startPositionBuffers.indices);

                gl.drawElements(gl.TRIANGLES, startPositionBuffers.indexCount, gl.UNSIGNED_SHORT, 0);
            }

            // Draw metal spot markers (yellow spheres)
            if (metalSpotBuffers && markerShaderProgram) {
                gl.useProgram(markerShaderProgram);

                gl.uniformMatrix4fv(markerShaderProgram.pMatrixUniform, false, projectionMatrix);
                gl.uniformMatrix4fv(markerShaderProgram.mvMatrixUniform, false, modelViewMatrix);

                // Yellow color for metal spots (matching 2D preview)
                gl.uniform3f(markerShaderProgram.colorUniform, 1.0, 1.0, 0.0);

                gl.bindBuffer(gl.ARRAY_BUFFER, metalSpotBuffers.position);
                gl.vertexAttribPointer(markerShaderProgram.vertexPositionAttribute, 3, gl.FLOAT, false, 0, 0);

                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, metalSpotBuffers.indices);

                gl.drawElements(gl.TRIANGLES, metalSpotBuffers.indexCount, gl.UNSIGNED_SHORT, 0);

                gl.useProgram(shaderProgram);
            }

            // Draw geothermal spot markers (red spheres)
            if (geoSpotBuffers && markerShaderProgram) {
                gl.useProgram(markerShaderProgram);

                gl.uniformMatrix4fv(markerShaderProgram.pMatrixUniform, false, projectionMatrix);
                gl.uniformMatrix4fv(markerShaderProgram.mvMatrixUniform, false, modelViewMatrix);

                // Red color for geothermal spots (matching 2D preview)
                gl.uniform3f(markerShaderProgram.colorUniform, 1.0, 0.0, 0.0);

                gl.bindBuffer(gl.ARRAY_BUFFER, geoSpotBuffers.position);
                gl.vertexAttribPointer(markerShaderProgram.vertexPositionAttribute, 3, gl.FLOAT, false, 0, 0);

                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, geoSpotBuffers.indices);

                gl.drawElements(gl.TRIANGLES, geoSpotBuffers.indexCount, gl.UNSIGNED_SHORT, 0);

                gl.useProgram(shaderProgram);
            }
        }

        // Render loop for continuous 3D terrain display
        let renderLoopId = null;
        function startRenderLoop() {
            if (renderLoopId !== null) {
                cancelAnimationFrame(renderLoopId);
            }

            function render() {
                drawScene();
                renderLoopId = requestAnimationFrame(render);
            }

            render();
        }

        // Update value displays
        function updateValueDisplays() {
            document.getElementById('noiseValue').textContent = document.getElementById('noiseStrength').value;
            document.getElementById('heightValue').textContent = document.getElementById('heightVariation').value;
            document.getElementById('waterValue').textContent = document.getElementById('waterLevel').value;
            document.getElementById('smoothValue').textContent = document.getElementById('smoothing').value;
            document.getElementById('metalValue').textContent = document.getElementById('metalSpots').value;
            document.getElementById('metalStrengthValue').textContent = document.getElementById('metalStrength').value;
            document.getElementById('geoValue').textContent = document.getElementById('geoSpots').value;
        }
        
        // Add event listeners for real-time updates
        document.querySelectorAll('input[type="range"]').forEach(slider => {
            slider.addEventListener('input', updateValueDisplays);
        });
        
        // Initialize displays
        updateValueDisplays();
        
        function generateMap() {
            console.log("=== Generiere Map-Vorschau ===");
            
            const size = parseInt(document.getElementById('mapSize').value);
            const terrainType = document.getElementById('terrainType').value;
            const playerCount = parseInt(document.getElementById('playerCount').value);
            const noiseStrength = parseFloat(document.getElementById('noiseStrength').value);
            const heightVariation = parseInt(document.getElementById('heightVariation').value);
            const waterLevel = parseInt(document.getElementById('waterLevel').value);
            const smoothing = parseInt(document.getElementById('smoothing').value);
            const metalSpots = parseInt(document.getElementById('metalSpots').value);
            const metalStrength = parseFloat(document.getElementById('metalStrength').value);
            const geoSpots = parseInt(document.getElementById('geoSpots').value);
            
            // Generate all data
            heightmapData = generateHeightmap(size, terrainType, noiseStrength, heightVariation, waterLevel, smoothing);
            textureData = generateTextureMap(size, heightmapData, waterLevel);

            // Auto-retry logic for balanced resource distribution
            const minFairnessScore = 80;
            const maxRetries = 10;
            let balance;
            let retryCount = 0;

            console.log(`\n=== RESOURCE GENERATION WITH AUTO-RETRY ===`);
            console.log(`Target Fairness Score: ${minFairnessScore}%`);
            console.log(`Maximum Retry Attempts: ${maxRetries}`);

            do {
                if (retryCount > 0) {
                    console.log(`\nüîÑ Retry attempt ${retryCount}/${maxRetries}...`);
                }

                // Generate resources using smart distribution algorithms:
                // - Territory-based balanced metal spot distribution (Voronoi regions)
                // - Strategic placement near terrain features (hills, ridges, valleys)
                // - Balanced metal values based on map size and player count
                // - Strategic geo vent placement (high ground, contested areas)
                // - Geo vent value variation by strategic importance
                resourceData = generateResourceMap(size, heightmapData, waterLevel, metalSpots, geoSpots, playerCount);

                // Calculate resource balance metrics (fairness score, per-player totals, territory analysis)
                balance = calculateResourceBalance(resourceData, playerCount);
                retryCount++;

                console.log(`Attempt ${retryCount}: Fairness Score = ${balance.summary.overallFairness}/100`);

                if (parseFloat(balance.summary.overallFairness) >= minFairnessScore) {
                    console.log(`‚úÖ Target fairness score achieved!`);
                    break;
                } else if (retryCount < maxRetries) {
                    console.log(`‚ö†Ô∏è  Fairness score below ${minFairnessScore}%, regenerating...`);
                }
            } while (retryCount < maxRetries && parseFloat(balance.summary.overallFairness) < minFairnessScore);

            if (retryCount === maxRetries && parseFloat(balance.summary.overallFairness) < minFairnessScore) {
                console.log(`‚ö†Ô∏è  Warning: Could not achieve target fairness score after ${maxRetries} attempts`);
                console.log(`Using best attempt: ${balance.summary.overallFairness}/100`);
            } else {
                console.log(`‚úÖ Fair distribution achieved in ${retryCount} attempt${retryCount > 1 ? 's' : ''}`);
            }

            // Calculate and log resource balance
            console.log('\n=== RESOURCE BALANCE ANALYSIS ===');
            console.log('Per-Player Resource Totals:');
            balance.perPlayer.forEach(p => {
                console.log(`  Player ${p.player}: ${p.metalSpotCount} spots, ${p.totalMetalValue.toFixed(1)} total metal (${p.avgMetalPerSpot.toFixed(2)} avg/spot)`);
            });
            console.log('\nTerritory Analysis:');
            balance.territoryAnalysis.forEach(t => {
                console.log(`  Player ${t.player}: ${t.territorySize.toLocaleString()} pixels (${t.territoryPercent.toFixed(1)}%), Balance: ${t.territoryBalance.toFixed(1)}%`);
            });
            console.log('\nFairness Metrics:');
            console.log(`  Spot Distribution CV: ${balance.summary.spotDistributionCV}%`);
            console.log(`  Metal Distribution CV: ${balance.summary.metalDistributionCV}%`);
            console.log(`  Territory Distribution CV: ${balance.summary.territoryDistributionCV}%`);
            console.log(`  Overall Fairness Score: ${balance.summary.overallFairness}/100`);
            console.log(`  Total Metal Spots: ${balance.summary.totalMetalSpots}`);
            console.log(`  Avg Metal per Spot: ${balance.summary.avgMetalPerSpot}`);
            console.log('================================\n');

            mapConfig = {
                size: size,
                terrainType: terrainType,
                playerCount: playerCount,
                noiseStrength: noiseStrength,
                heightVariation: heightVariation,
                waterLevel: waterLevel,
                metalSpots: metalSpots,
                metalStrength: metalStrength,
                geoSpots: geoSpots,
                startPositions: generateStartPositions(size, playerCount, heightmapData, waterLevel),
                metalSpotLocations: resourceData.metalSpots,
                geoSpotLocations: resourceData.geoSpots
            };
            
            console.log("All data generated successfully");

            // Draw all previews - NO DOWNLOADS!
            try {
                drawHeightmap(heightmapData, size);
                drawTextureMap(textureData, size);
                drawResourceMap(resourceData, size, mapConfig.startPositions);
                console.log("All maps drawn successfully");
            } catch (error) {
                console.error("Error drawing maps:", error);
                alert("Error drawing maps: " + error.message);
            }

            // Generate and render 3D terrain
            try {
                const mesh = generateTerrainMesh(heightmapData, size);
                terrainBuffers = uploadMeshDataToBuffers(mesh);
                if (terrainBuffers) {
                    // Generate and upload start position markers (green cones)
                    const startPositionMesh = generateStartPositionMeshes(mapConfig.startPositions, heightmapData, size, waterLevel);
                    startPositionBuffers = uploadMarkerDataToBuffers(startPositionMesh);

                    // Generate and upload metal spot markers (yellow spheres)
                    const metalSpotMesh = generateMetalSpotMeshes(mapConfig.metalSpotLocations, heightmapData, size, waterLevel);
                    metalSpotBuffers = uploadMarkerDataToBuffers(metalSpotMesh);

                    // Generate and upload geothermal spot markers (red spheres)
                    const geoSpotMesh = generateGeoSpotMeshes(mapConfig.geoSpotLocations, heightmapData, size, waterLevel);
                    geoSpotBuffers = uploadMarkerDataToBuffers(geoSpotMesh);

                    startRenderLoop();
                    console.log("3D terrain rendering started");
                }
            } catch (error) {
                console.error("Error rendering 3D terrain:", error);
            }
        }
        
        function randomizeSettings() {
            const terrainTypes = ['continental', 'islands', 'canyon', 'hills', 'flat'];
            const playerCounts = [2, 4, 6, 8];
            
            document.getElementById('terrainType').value = terrainTypes[Math.floor(Math.random() * terrainTypes.length)];
            document.getElementById('playerCount').value = playerCounts[Math.floor(Math.random() * playerCounts.length)];
            document.getElementById('noiseStrength').value = (0.2 + Math.random() * 0.8).toFixed(1);
            document.getElementById('heightVariation').value = Math.floor(80 + Math.random() * 175);
            document.getElementById('waterLevel').value = Math.floor(Math.random() * 100);
            document.getElementById('smoothing').value = Math.floor(Math.random() * 4);
            document.getElementById('metalSpots').value = Math.floor(15 + Math.random() * 30);
            document.getElementById('metalStrength').value = (1.5 + Math.random() * 3).toFixed(1);
            document.getElementById('geoSpots').value = Math.floor(3 + Math.random() * 8);
            
            updateValueDisplays();
        }
        
        function generateHeightmap(size, terrainType, noiseStrength, heightVariation, waterLevel, smoothing) {
            const data = new Array(size * size);
            
            // Base terrain generation
            for (let y = 0; y < size; y++) {
                for (let x = 0; x < size; x++) {
                    const index = y * size + x;
                    let height = 0;
                    
                    switch (terrainType) {
                        case 'continental':
                            height = generateContinentalTerrain(x, y, size, noiseStrength);
                            break;
                        case 'islands':
                            height = generateIslandTerrain(x, y, size, noiseStrength);
                            break;
                        case 'canyon':
                            height = generateCanyonTerrain(x, y, size, noiseStrength);
                            break;
                        case 'hills':
                            height = generateHillyTerrain(x, y, size, noiseStrength);
                            break;
                        case 'flat':
                            height = generateFlatTerrain(x, y, size, noiseStrength);
                            break;
                    }
                    
                    data[index] = Math.max(0, Math.min(255, height * heightVariation));
                }
            }
            
            // Apply smoothing
            for (let i = 0; i < smoothing; i++) {
                smoothHeightmap(data, size);
            }
            
            return data;
        }
        
        function generateContinentalTerrain(x, y, size, noiseStrength) {
            const centerX = size / 2;
            const centerY = size / 2;
            const maxDist = Math.sqrt(centerX * centerX + centerY * centerY);
            const dist = Math.sqrt((x - centerX) ** 2 + (y - centerY) ** 2);
            
            const baseHeight = 1 - (dist / maxDist) * 0.7;
            const noise = (noise2D(x * 0.01, y * 0.01) + noise2D(x * 0.005, y * 0.005) * 0.5) * noiseStrength;
            
            return Math.max(0, baseHeight + noise);
        }
        
        function generateIslandTerrain(x, y, size, noiseStrength) {
            const islands = [
                { x: size * 0.3, y: size * 0.3, radius: size * 0.2 },
                { x: size * 0.7, y: size * 0.7, radius: size * 0.2 },
                { x: size * 0.2, y: size * 0.8, radius: size * 0.15 },
                { x: size * 0.8, y: size * 0.2, radius: size * 0.15 }
            ];
            
            let height = 0;
            islands.forEach(island => {
                const dist = Math.sqrt((x - island.x) ** 2 + (y - island.y) ** 2);
                if (dist < island.radius) {
                    height = Math.max(height, 1 - (dist / island.radius));
                }
            });
            
            const noise = noise2D(x * 0.01, y * 0.01) * noiseStrength;
            return Math.max(0, height + noise);
        }
        
        function generateCanyonTerrain(x, y, size, noiseStrength) {
            const canyonCenter = size / 2;
            const distFromCenter = Math.abs(y - canyonCenter) / (size / 2);
            
            let height = distFromCenter;
            const noise = noise2D(x * 0.008, y * 0.008) * noiseStrength;
            
            return Math.max(0.1, height + noise);
        }
        
        function generateHillyTerrain(x, y, size, noiseStrength) {
            const noise1 = noise2D(x * 0.008, y * 0.008);
            const noise2 = noise2D(x * 0.015, y * 0.015) * 0.5;
            const noise3 = noise2D(x * 0.03, y * 0.03) * 0.25;
            
            return Math.max(0.2, (noise1 + noise2 + noise3) * noiseStrength + 0.3);
        }
        
        function generateFlatTerrain(x, y, size, noiseStrength) {
            const noise = noise2D(x * 0.02, y * 0.02) * noiseStrength * 0.3;
            return 0.4 + noise;
        }
        
        function noise2D(x, y) {
            // Simple 2D noise function
            const n = Math.sin(x * 12.9898 + y * 78.233) * 43758.5453;
            return (n - Math.floor(n)) * 2 - 1;
        }
        
        function smoothHeightmap(data, size) {
            const newData = [...data];
            for (let y = 1; y < size - 1; y++) {
                for (let x = 1; x < size - 1; x++) {
                    const index = y * size + x;
                    let sum = 0;
                    let count = 0;

                    for (let dy = -1; dy <= 1; dy++) {
                        for (let dx = -1; dx <= 1; dx++) {
                            sum += data[(y + dy) * size + (x + dx)];
                            count++;
                        }
                    }

                    newData[index] = sum / count;
                }
            }

            for (let i = 0; i < data.length; i++) {
                data[i] = newData[i];
            }
        }

        // Terrain Analysis Utility Functions
        function calculateSlope(heightmapData, size) {
            const slopeData = new Array(size * size);

            for (let y = 1; y < size - 1; y++) {
                for (let x = 1; x < size - 1; x++) {
                    const index = y * size + x;

                    const center = heightmapData[index];
                    const left = heightmapData[y * size + (x - 1)];
                    const right = heightmapData[y * size + (x + 1)];
                    const top = heightmapData[(y - 1) * size + x];
                    const bottom = heightmapData[(y + 1) * size + x];

                    const dzdx = (right - left) / 2;
                    const dzdy = (bottom - top) / 2;

                    slopeData[index] = Math.sqrt(dzdx * dzdx + dzdy * dzdy);
                }
            }

            for (let x = 0; x < size; x++) {
                slopeData[x] = 0;
                slopeData[(size - 1) * size + x] = 0;
            }
            for (let y = 0; y < size; y++) {
                slopeData[y * size] = 0;
                slopeData[y * size + (size - 1)] = 0;
            }

            return slopeData;
        }

        function identifyHills(heightmapData, size, waterLevel) {
            const hills = [];
            const visited = new Set();
            const heightThreshold = waterLevel + 80;

            for (let y = 2; y < size - 2; y++) {
                for (let x = 2; x < size - 2; x++) {
                    const index = y * size + x;
                    const height = heightmapData[index];

                    if (height > heightThreshold && !visited.has(index)) {
                        let isPeak = true;
                        let neighborCount = 0;
                        let lowerNeighborCount = 0;

                        for (let dy = -2; dy <= 2; dy++) {
                            for (let dx = -2; dx <= 2; dx++) {
                                if (dx === 0 && dy === 0) continue;

                                const neighborIndex = (y + dy) * size + (x + dx);
                                const neighborHeight = heightmapData[neighborIndex];
                                neighborCount++;

                                if (neighborHeight >= height) {
                                    isPeak = false;
                                } else if (neighborHeight < height - 10) {
                                    lowerNeighborCount++;
                                }
                            }
                        }

                        if (isPeak || lowerNeighborCount > neighborCount * 0.6) {
                            const peakIndex = index;
                            const hill = {
                                x: x,
                                y: y,
                                height: height,
                                radius: 0
                            };

                            let maxRadius = 0;
                            for (let r = 1; r < 15; r++) {
                                let pointsAtRadius = 0;
                                let pointsAboveThreshold = 0;

                                for (let angle = 0; angle < Math.PI * 2; angle += Math.PI / 8) {
                                    const checkX = Math.round(x + Math.cos(angle) * r);
                                    const checkY = Math.round(y + Math.sin(angle) * r);

                                    if (checkX >= 0 && checkX < size && checkY >= 0 && checkY < size) {
                                        pointsAtRadius++;
                                        const checkHeight = heightmapData[checkY * size + checkX];
                                        if (checkHeight > waterLevel + 30) {
                                            pointsAboveThreshold++;
                                        }
                                    }
                                }

                                if (pointsAboveThreshold / pointsAtRadius > 0.5) {
                                    maxRadius = r;
                                } else {
                                    break;
                                }
                            }

                            hill.radius = maxRadius;
                            hills.push(hill);

                            for (let dy = -maxRadius; dy <= maxRadius; dy++) {
                                for (let dx = -maxRadius; dx <= maxRadius; dx++) {
                                    const visitX = x + dx;
                                    const visitY = y + dy;
                                    if (visitX >= 0 && visitX < size && visitY >= 0 && visitY < size) {
                                        const dist = Math.sqrt(dx * dx + dy * dy);
                                        if (dist <= maxRadius) {
                                            visited.add(visitY * size + visitX);
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }

            return hills;
        }

        function findValleys(heightmapData, size, waterLevel) {
            const valleys = [];
            const visited = new Set();
            const maxHeightThreshold = waterLevel + 50;

            for (let y = 2; y < size - 2; y++) {
                for (let x = 2; x < size - 2; x++) {
                    const index = y * size + x;
                    const height = heightmapData[index];

                    if (height > waterLevel + 5 && height < maxHeightThreshold && !visited.has(index)) {
                        let isValleyBottom = true;
                        let neighborCount = 0;
                        let higherNeighborCount = 0;

                        for (let dy = -2; dy <= 2; dy++) {
                            for (let dx = -2; dx <= 2; dx++) {
                                if (dx === 0 && dy === 0) continue;

                                const neighborIndex = (y + dy) * size + (x + dx);
                                const neighborHeight = heightmapData[neighborIndex];
                                neighborCount++;

                                if (neighborHeight < height) {
                                    isValleyBottom = false;
                                } else if (neighborHeight > height + 10) {
                                    higherNeighborCount++;
                                }
                            }
                        }

                        if (isValleyBottom || higherNeighborCount > neighborCount * 0.6) {
                            const valley = {
                                x: x,
                                y: y,
                                height: height,
                                radius: 0
                            };

                            let maxRadius = 0;
                            for (let r = 1; r < 12; r++) {
                                let pointsAtRadius = 0;
                                let pointsBelowThreshold = 0;

                                for (let angle = 0; angle < Math.PI * 2; angle += Math.PI / 8) {
                                    const checkX = Math.round(x + Math.cos(angle) * r);
                                    const checkY = Math.round(y + Math.sin(angle) * r);

                                    if (checkX >= 0 && checkX < size && checkY >= 0 && checkY < size) {
                                        pointsAtRadius++;
                                        const checkHeight = heightmapData[checkY * size + checkX];
                                        if (checkHeight < maxHeightThreshold && checkHeight > waterLevel + 5) {
                                            pointsBelowThreshold++;
                                        }
                                    }
                                }

                                if (pointsBelowThreshold / pointsAtRadius > 0.5) {
                                    maxRadius = r;
                                } else {
                                    break;
                                }
                            }

                            valley.radius = maxRadius;
                            valleys.push(valley);

                            for (let dy = -maxRadius; dy <= maxRadius; dy++) {
                                for (let dx = -maxRadius; dx <= maxRadius; dx++) {
                                    const visitX = x + dx;
                                    const visitY = y + dy;
                                    if (visitX >= 0 && visitX < size && visitY >= 0 && visitY < size) {
                                        const dist = Math.sqrt(dx * dx + dy * dy);
                                        if (dist <= maxRadius) {
                                            visited.add(visitY * size + visitX);
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }

            return valleys;
        }

        function analyzeTerrain(heightmapData, size, waterLevel) {
            const slopeData = calculateSlope(heightmapData, size);
            const hills = identifyHills(heightmapData, size, waterLevel);
            const valleys = findValleys(heightmapData, size, waterLevel);

            return {
                slope: slopeData,
                hills: hills,
                valleys: valleys
            };
        }

        function generateVoronoiTerritories(startPositions, size) {
            const territories = new Int8Array(size * size);

            for (let y = 0; y < size; y++) {
                for (let x = 0; x < size; x++) {
                    const index = y * size + x;
                    let nearestPlayer = 0;
                    let minDistance = Infinity;

                    for (let i = 0; i < startPositions.length; i++) {
                        const pos = startPositions[i];
                        const dist = Math.sqrt((x - pos.x) ** 2 + (y - pos.y) ** 2);

                        if (dist < minDistance) {
                            minDistance = dist;
                            nearestPlayer = i;
                        }
                    }

                    territories[index] = nearestPlayer;
                }
            }

            return {
                territories: territories,
                startPositions: startPositions
            };
        }

        function generateTextureMap(size, heightmapData, waterLevel) {
            const textureData = new Array(size * size * 4); // RGBA
            
            for (let i = 0; i < size * size; i++) {
                const height = heightmapData[i];
                const index = i * 4;
                
                if (height < waterLevel) {
                    // Water - blue
                    textureData[index] = 30;      // R
                    textureData[index + 1] = 100; // G
                    textureData[index + 2] = 200; // B
                } else if (height < waterLevel + 20) {
                    // Beach/Sand - yellow
                    textureData[index] = 255;     // R
                    textureData[index + 1] = 230; // G
                    textureData[index + 2] = 150; // B
                } else if (height < waterLevel + 80) {
                    // Grass - green
                    textureData[index] = 50;      // R
                    textureData[index + 1] = 150; // G
                    textureData[index + 2] = 50;  // B
                } else if (height < waterLevel + 120) {
                    // Rock - gray
                    textureData[index] = 120;     // R
                    textureData[index + 1] = 120; // G
                    textureData[index + 2] = 120; // B
                } else {
                    // Snow - white
                    textureData[index] = 240;     // R
                    textureData[index + 1] = 240; // G
                    textureData[index + 2] = 255; // B
                }
                
                textureData[index + 3] = 255; // Alpha
            }
            
            return textureData;
        }
        
        function calculateStrategicScore(x, y, height, terrainAnalysis, size, waterLevel) {
            let score = 0;
            const hills = terrainAnalysis.hills;
            const valleys = terrainAnalysis.valleys;

            // Factor 1: Height advantage (higher is better for metal spots)
            const normalizedHeight = (height - waterLevel) / 255;
            score += normalizedHeight * 30;

            // Factor 2: Proximity to hills (closer is better)
            let minHillDistance = Infinity;
            for (const hill of hills) {
                const dist = Math.sqrt((x - hill.x) ** 2 + (y - hill.y) ** 2);
                if (dist < minHillDistance) {
                    minHillDistance = dist;
                }
            }

            if (minHillDistance !== Infinity) {
                // Score decreases with distance from hills
                const normalizedDist = Math.min(minHillDistance / (size * 0.15), 1);
                score += (1 - normalizedDist) * 40;
            }

            // Factor 3: Ridge positioning (between two hills is strategic)
            let ridgeScore = 0;
            for (let i = 0; i < hills.length; i++) {
                for (let j = i + 1; j < hills.length; j++) {
                    const hill1 = hills[i];
                    const hill2 = hills[j];

                    // Check if position lies approximately on the line between hills
                    const dist1 = Math.sqrt((x - hill1.x) ** 2 + (y - hill1.y) ** 2);
                    const dist2 = Math.sqrt((x - hill2.x) ** 2 + (y - hill2.y) ** 2);
                    const hillDist = Math.sqrt((hill1.x - hill2.x) ** 2 + (hill1.y - hill2.y) ** 2);

                    if (Math.abs(dist1 + dist2 - hillDist) < 20) {
                        // Position is on ridge between hills
                        ridgeScore = Math.max(ridgeScore, 25);
                    }
                }
            }
            score += ridgeScore;

            // Factor 4: Avoid deep valleys (penalty)
            let minValleyDistance = Infinity;
            for (const valley of valleys) {
                const dist = Math.sqrt((x - valley.x) ** 2 + (y - valley.y) ** 2);
                if (dist < minValleyDistance) {
                    minValleyDistance = dist;
                }
            }

            if (minValleyDistance !== Infinity && minValleyDistance < size * 0.08) {
                // Penalty for being in or very near a valley
                const normalizedValleyDist = minValleyDistance / (size * 0.08);
                score -= (1 - normalizedValleyDist) * 15;
            }

            // Add some randomness to prevent predictable patterns
            score += Math.random() * 10;

            return Math.max(0, score);
        }

        function calculateGeoStrategicScore(x, y, height, terrainAnalysis, size, waterLevel, territories, playerCount) {
            let score = 0;
            const hills = terrainAnalysis.hills;
            const valleys = terrainAnalysis.valleys;

            // Factor 1: Height advantage (geo vents prefer high ground)
            const normalizedHeight = (height - waterLevel) / 255;
            score += normalizedHeight * 40;

            // Factor 2: Hilltop placement (geo vents on peaks are strategic)
            let maxHillProximity = 0;
            for (const hill of hills) {
                const dist = Math.sqrt((x - hill.x) ** 2 + (y - hill.y) ** 2);
                if (dist < hill.radius) {
                    // Bonus for being on a hill
                    const proximityScore = (1 - dist / hill.radius) * 35;
                    maxHillProximity = Math.max(maxHillProximity, proximityScore);
                }
            }
            score += maxHillProximity;

            // Factor 3: Ridge positioning (between hills)
            let ridgeScore = 0;
            for (let i = 0; i < Math.min(hills.length, 10); i++) {
                for (let j = i + 1; j < Math.min(hills.length, 10); j++) {
                    const hill1 = hills[i];
                    const hill2 = hills[j];

                    const dist1 = Math.sqrt((x - hill1.x) ** 2 + (y - hill1.y) ** 2);
                    const dist2 = Math.sqrt((x - hill2.x) ** 2 + (y - hill2.y) ** 2);
                    const hillDist = Math.sqrt((hill1.x - hill2.x) ** 2 + (hill1.y - hill2.y) ** 2);

                    if (Math.abs(dist1 + dist2 - hillDist) < 15) {
                        const avgHeight = (hill1.height + hill2.height) / 2;
                        if (avgHeight > waterLevel + 100) {
                            ridgeScore = Math.max(ridgeScore, 30);
                        }
                    }
                }
            }
            score += ridgeScore;

            // Factor 4: Contested areas (near territory boundaries)
            const territoryIndex = y * size + x;
            const currentTerritory = territories[territoryIndex];
            let boundaryScore = 0;

            // Check surrounding cells for different territories
            for (let dy = -3; dy <= 3; dy++) {
                for (let dx = -3; dx <= 3; dx++) {
                    if (dx === 0 && dy === 0) continue;

                    const checkX = x + dx;
                    const checkY = y + dy;

                    if (checkX >= 0 && checkX < size && checkY >= 0 && checkY < size) {
                        const checkIndex = checkY * size + checkX;
                        if (territories[checkIndex] !== currentTerritory) {
                            const dist = Math.sqrt(dx * dx + dy * dy);
                            if (dist <= 3) {
                                boundaryScore += (3 - dist) / 3;
                            }
                        }
                    }
                }
            }

            // Normalize boundary score (max possible is around 24)
            boundaryScore = Math.min(boundaryScore / 24, 1) * 30;
            score += boundaryScore;

            // Factor 5: Avoid valleys (geo vents shouldn't be in low areas)
            let minValleyDistance = Infinity;
            for (const valley of valleys) {
                const dist = Math.sqrt((x - valley.x) ** 2 + (y - valley.y) ** 2);
                if (dist < minValleyDistance) {
                    minValleyDistance = dist;
                }
            }

            if (minValleyDistance !== Infinity && minValleyDistance < size * 0.1) {
                const normalizedValleyDist = minValleyDistance / (size * 0.1);
                score -= (1 - normalizedValleyDist) * 25;
            }

            // Add some randomness for variety
            score += Math.random() * 8;

            return Math.max(0, score);
        }

        function calculateMetalSpotValue(mapSize, playerCount, metalStrength, strategicScore, maxScore) {
            // Base metal value depends on map size and player count
            // Larger maps and more players require value adjustments

            // Map size multiplier (larger maps get slight boost)
            const sizeMultipliers = {
                512: 0.9,   // Small maps - compact, faster access
                1024: 1.0,  // Medium maps - baseline
                2048: 1.1   // Large maps - spread out, need slightly higher values
            };
            const sizeMultiplier = sizeMultipliers[mapSize] || 1.0;

            // Player count adjustment (more players = more competition, scale values down slightly)
            // This ensures total map metal doesn't scale linearly with players
            const playerAdjustment = 1.0 - (playerCount - 2) * 0.05;

            // Strategic score multiplier (0.8 to 1.2 based on position quality)
            const strategicMultiplier = 0.8 + (strategicScore / maxScore) * 0.4;

            // Calculate base value using metalStrength as a baseline multiplier
            const baseValue = metalStrength * sizeMultiplier * playerAdjustment * strategicMultiplier;

            // Add some variation (¬±15%) for map diversity
            const variation = 0.85 + Math.random() * 0.3;

            // Final value with reasonable bounds (1.0 to 5.0 range)
            let finalValue = baseValue * variation;
            finalValue = Math.max(1.0, Math.min(5.0, finalValue));

            return finalValue;
        }

        function calculateGeoVentValue(strategicScore, maxScore) {
            // Geo vent value based on strategic importance
            // Higher strategic score = more valuable geo vent (200-500 energy range)

            // Base value (200 energy)
            const baseValue = 200;

            // Strategic bonus (0-300 energy based on score ratio)
            // Best strategic locations get up to 500 energy
            const strategicBonus = (strategicScore / maxScore) * 300;

            // Small random variation (¬±25 energy) for natural feel
            const randomVariation = Math.random() * 50 - 25;

            // Final value with bounds
            let finalValue = baseValue + strategicBonus + randomVariation;
            finalValue = Math.max(150, Math.min(550, finalValue));

            return finalValue;
        }

        function generateResourceMap(size, heightmapData, waterLevel, metalSpots, geoSpots, playerCount) {
            const resourceData = {
                metalSpots: [],
                geoSpots: [],
                size: size
            };

            // Get metal strength parameter for value calculation
            const metalStrength = parseFloat(document.getElementById('metalStrength').value);

            // Analyze terrain for strategic features
            const terrainAnalysis = analyzeTerrain(heightmapData, size, waterLevel);
            console.log(`Strategic Placement: Found ${terrainAnalysis.hills.length} hills, ${terrainAnalysis.valleys.length} valleys`);

            // Generate start positions for territory division
            const startPositions = generateStartPositions(size, playerCount, heightmapData, waterLevel);

            // Generate Voronoi territories
            const voronoiData = generateVoronoiTerritories(startPositions, size);
            const territories = voronoiData.territories;

            // Calculate metal spots per player (balanced distribution)
            const baseSpotsPerPlayer = Math.floor(metalSpots / playerCount);
            const extraSpots = metalSpots % playerCount;

            // Track metal spots per territory for verification
            const spotsPerTerritory = new Array(playerCount).fill(0);
            const metalPerTerritory = new Array(playerCount).fill(0);

            // Generate metal spots per territory
            for (let player = 0; player < playerCount; player++) {
                // Calculate spots for this player (some get +1 for balance)
                const spotsForPlayer = baseSpotsPerPlayer + (player < extraSpots ? 1 : 0);

                // Collect and score valid positions within this player's territory
                const scoredPositions = [];
                for (let y = 0; y < size; y++) {
                    for (let x = 0; x < size; x++) {
                        const index = y * size + x;
                        if (territories[index] === player) {
                            const height = heightmapData[index];
                            if (height > waterLevel + 10) {
                                const score = calculateStrategicScore(x, y, height, terrainAnalysis, size, waterLevel);
                                scoredPositions.push({ x, y, score });
                            }
                        }
                    }
                }

                // Sort positions by strategic score (descending)
                scoredPositions.sort((a, b) => b.score - a.score);

                // Place metal spots strategically (prefer high-scoring positions)
                const maxStrategicScore = scoredPositions.length > 0 ? scoredPositions[0].score : 1.0;

                for (let i = 0; i < spotsForPlayer && scoredPositions.length > 0; i++) {
                    let placedSpot = false;
                    let searchIndex = 0;

                    // Try to place from highest-scoring positions first
                    while (!placedSpot && searchIndex < scoredPositions.length) {
                        const { x, y, score } = scoredPositions[searchIndex];
                        const height = heightmapData[y * size + x];

                        // Check distance from other metal spots
                        let tooClose = false;
                        for (const spot of resourceData.metalSpots) {
                            const dist = Math.sqrt((x - spot.x) ** 2 + (y - spot.y) ** 2);
                            if (dist < size * 0.05) {
                                tooClose = true;
                                break;
                            }
                        }

                        if (!tooClose) {
                            // Calculate balanced metal value based on map size, player count, and strategic score
                            const metalValue = calculateMetalSpotValue(size, playerCount, metalStrength, score, maxStrategicScore);

                            resourceData.metalSpots.push({
                                x,
                                y,
                                value: metalValue,
                                territory: player
                            });
                            spotsPerTerritory[player]++;
                            metalPerTerritory[player] += metalValue;
                            placedSpot = true;
                        }

                        searchIndex++;
                    }
                }
            }

            // Log metal spot distribution for verification
            console.log('Metal Spot Distribution by Territory:');
            spotsPerTerritory.forEach((count, idx) => {
                console.log(`  Player ${idx + 1}: ${count} spots, Total Metal: ${metalPerTerritory[idx].toFixed(1)} (${(metalPerTerritory[idx] / count).toFixed(2)} avg/spot)`);
            });
            const minSpots = Math.min(...spotsPerTerritory);
            const maxSpots = Math.max(...spotsPerTerritory);
            const minMetal = Math.min(...metalPerTerritory);
            const maxMetal = Math.max(...metalPerTerritory);
            const avgMetal = metalPerTerritory.reduce((a, b) => a + b, 0) / playerCount;
            console.log(`  Spot Balance: ${minSpots} - ${maxSpots} (difference: ${maxSpots - minSpots})`);
            console.log(`  Metal Balance: ${minMetal.toFixed(1)} - ${maxMetal.toFixed(1)} (difference: ${(maxMetal - minMetal).toFixed(1)})`);
            console.log(`  Average Metal per Player: ${avgMetal.toFixed(1)}`);
            console.log(`  Map Size: ${size}, Player Count: ${playerCount}, Metal Strength: ${metalStrength.toFixed(1)}`);

            // Generate geo spots with strategic placement (high ground, chokepoints, contested areas)
            console.log('Geo Spot Strategic Placement:');

            // Sample candidate positions across the map
            const candidateStep = Math.max(size / 50, 4);
            const candidates = [];

            for (let y = 2; y < size - 2; y += candidateStep) {
                for (let x = 2; x < size - 2; x += candidateStep) {
                    const height = heightmapData[y * size + x];

                    if (height > waterLevel + 30) {
                        const score = calculateGeoStrategicScore(
                            x, y, height, terrainAnalysis, size, waterLevel,
                            territories.territories, playerCount
                        );
                        candidates.push({ x, y, height, score });
                    }
                }
            }

            // Sort by strategic score (highest first)
            candidates.sort((a, b) => b.score - a.score);

            // Place geo spots at highest-scoring locations
            let placedGeoSpots = 0;
            const maxGeoScore = candidates.length > 0 ? candidates[0].score : 1.0;

            for (const candidate of candidates) {
                if (placedGeoSpots >= geoSpots) break;

                const { x, y, score } = candidate;

                // Check distance from other geo spots
                let tooClose = false;
                for (const spot of resourceData.geoSpots) {
                    const dist = Math.sqrt((x - spot.x) ** 2 + (y - spot.y) ** 2);
                    if (dist < size * 0.12) {
                        tooClose = true;
                        break;
                    }
                }

                if (!tooClose) {
                    // Geo value based on strategic score
                    const geoValue = calculateGeoVentValue(score, maxGeoScore);
                    resourceData.geoSpots.push({ x, y, value: geoValue });
                    placedGeoSpots++;

                    // Log placement details with value
                    const hillBonus = terrainAnalysis.hills.some(hill => {
                        const dist = Math.sqrt((x - hill.x) ** 2 + (y - hill.y) ** 2);
                        return dist < hill.radius;
                    }) ? 'On Hill' : 'Ground';
                    console.log(`  Geo ${placedGeoSpots}: (${x}, ${y}) - Score: ${score.toFixed(1)}, Value: ${geoValue.toFixed(1)} - ${hillBonus}`);
                }
            }

            console.log(`  Total Geo Spots Placed: ${placedGeoSpots}`);

            // Log geo vent value statistics
            if (placedGeoSpots > 0) {
                const geoValues = resourceData.geoSpots.map(spot => spot.value);
                const minValue = Math.min(...geoValues);
                const maxValue = Math.max(...geoValues);
                const avgValue = geoValues.reduce((a, b) => a + b, 0) / placedGeoSpots;
                console.log(`  Geo Vent Value Range: ${minValue.toFixed(1)} - ${maxValue.toFixed(1)} (average: ${avgValue.toFixed(1)})`);
                console.log(`  Strategic Value Variation: ${((maxValue - minValue) / avgValue * 100).toFixed(1)}%`);
            }

            // Add territory data to resourceData for visualization
            resourceData.territories = territories;
            resourceData.spotsPerTerritory = spotsPerTerritory;

            return resourceData;
        }

        function calculateResourceBalance(resourceData, playerCount) {
            const balance = {
                perPlayer: [],
                territoryAnalysis: [],
                fairnessScore: 0,
                summary: {}
            };

            // Calculate per-player resource totals
            for (let player = 0; player < playerCount; player++) {
                const playerSpots = resourceData.metalSpots.filter(spot => spot.territory === player);
                const totalMetal = playerSpots.reduce((sum, spot) => sum + spot.value, 0);
                const avgMetalPerSpot = playerSpots.length > 0 ? totalMetal / playerSpots.length : 0;

                balance.perPlayer.push({
                    player: player + 1,
                    metalSpotCount: playerSpots.length,
                    totalMetalValue: totalMetal,
                    avgMetalPerSpot: avgMetalPerSpot
                });
            }

            // Analyze territories
            if (resourceData.territories && resourceData.territories.territories) {
                const territoryMap = resourceData.territories.territories;
                const size = resourceData.size;
                const totalPixels = size * size;

                for (let player = 0; player < playerCount; player++) {
                    let territoryPixels = 0;
                    let landPixels = 0;

                    for (let i = 0; i < territoryMap.length; i++) {
                        if (territoryMap[i] === player) {
                            territoryPixels++;
                        }
                    }

                    // Calculate land area from spots (approximate using metal spot locations)
                    const playerSpots = resourceData.metalSpots.filter(spot => spot.territory === player);
                    landPixels = playerSpots.length * 100; // Approximate land area per spot

                    const territoryPercent = (territoryPixels / totalPixels) * 100;
                    const expectedPercent = 100 / playerCount;
                    const territoryBalance = (territoryPercent / expectedPercent) * 100;

                    balance.territoryAnalysis.push({
                        player: player + 1,
                        territorySize: territoryPixels,
                        territoryPercent: territoryPercent,
                        landArea: landPixels,
                        territoryBalance: territoryBalance
                    });
                }
            }

            // Calculate fairness scores using coefficient of variation (CV)
            // CV = (standard deviation / mean) * 100
            // Lower CV = more balanced distribution
            const calculateCV = (values) => {
                if (values.length === 0) return 0;
                const mean = values.reduce((a, b) => a + b, 0) / values.length;
                if (mean === 0) return 0;
                const variance = values.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / values.length;
                const stdDev = Math.sqrt(variance);
                return (stdDev / mean) * 100;
            };

            const spotCounts = balance.perPlayer.map(p => p.metalSpotCount);
            const metalTotals = balance.perPlayer.map(p => p.totalMetalValue);
            const territorySizes = balance.territoryAnalysis.map(t => t.territorySize);

            const spotCV = calculateCV(spotCounts);
            const metalCV = calculateCV(metalTotals);
            const territoryCV = calculateCV(territorySizes);

            // Overall fairness score (0-100, higher is better)
            // CV of 0% = 100% fair, CV of 25%+ = 0% fair
            const cvToFairness = (cv) => Math.max(0, 100 - (cv * 4));

            const spotFairness = cvToFairness(spotCV);
            const metalFairness = cvToFairness(metalCV);
            const territoryFairness = cvToFairness(territoryCV);

            // Weighted average: metal distribution is most important
            balance.fairnessScore = (
                metalFairness * 0.5 +
                spotFairness * 0.3 +
                territoryFairness * 0.2
            );

            balance.summary = {
                spotDistributionCV: spotCV.toFixed(1),
                metalDistributionCV: metalCV.toFixed(1),
                territoryDistributionCV: territoryCV.toFixed(1),
                spotFairness: spotFairness.toFixed(1),
                metalFairness: metalFairness.toFixed(1),
                territoryFairness: territoryFairness.toFixed(1),
                overallFairness: balance.fairnessScore.toFixed(1),
                totalMetalSpots: resourceData.metalSpots.length,
                avgMetalPerSpot: (metalTotals.reduce((a, b) => a + b, 0) / resourceData.metalSpots.length).toFixed(2)
            };

            return balance;
        }

        function generateStartPositions(size, playerCount, heightmapData, waterLevel) {
            const positions = [];
            const radius = size * 0.35;
            const centerX = size / 2;
            const centerY = size / 2;
            
            for (let i = 0; i < playerCount; i++) {
                const angle = (i / playerCount) * 2 * Math.PI;
                let x = Math.floor(centerX + Math.cos(angle) * radius);
                let y = Math.floor(centerY + Math.sin(angle) * radius);
                
                // Ensure position is on land
                let attempts = 0;
                while (heightmapData[y * size + x] <= waterLevel && attempts < 50) {
                    x = Math.floor(centerX + Math.cos(angle) * (radius + Math.random() * 50 - 25));
                    y = Math.floor(centerY + Math.sin(angle) * (radius + Math.random() * 50 - 25));
                    attempts++;
                }
                
                positions.push({ x, y, team: i + 1 });
            }
            
            return positions;
        }
        
        // DRAWING FUNCTIONS - ONLY FOR PREVIEW, NO DOWNLOADS!
        function drawHeightmap(data, size) {
            const canvas = document.getElementById('heightmapCanvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 512;
            canvas.height = 512;
            
            const imageData = ctx.createImageData(512, 512);
            const scale = size / 512;
            
            for (let y = 0; y < 512; y++) {
                for (let x = 0; x < 512; x++) {
                    const sourceX = Math.floor(x * scale);
                    const sourceY = Math.floor(y * scale);
                    const height = data[sourceY * size + sourceX];
                    const index = (y * 512 + x) * 4;
                    
                    imageData.data[index] = height;     // R
                    imageData.data[index + 1] = height; // G
                    imageData.data[index + 2] = height; // B
                    imageData.data[index + 3] = 255;    // A
                }
            }
            
            ctx.putImageData(imageData, 0, 0);
            console.log("Heightmap drawn to canvas - NO DOWNLOAD");
        }
        
        function drawTextureMap(data, size) {
            const canvas = document.getElementById('textureCanvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 512;
            canvas.height = 512;
            
            const imageData = ctx.createImageData(512, 512);
            const scale = size / 512;
            
            for (let y = 0; y < 512; y++) {
                for (let x = 0; x < 512; x++) {
                    const sourceX = Math.floor(x * scale);
                    const sourceY = Math.floor(y * scale);
                    const sourceIndex = (sourceY * size + sourceX) * 4;
                    const index = (y * 512 + x) * 4;
                    
                    imageData.data[index] = data[sourceIndex];         // R
                    imageData.data[index + 1] = data[sourceIndex + 1]; // G
                    imageData.data[index + 2] = data[sourceIndex + 2]; // B
                    imageData.data[index + 3] = 255;                   // A
                }
            }
            
            ctx.putImageData(imageData, 0, 0);
            console.log("Texture map drawn to canvas - NO DOWNLOAD");
        }
        
        function drawResourceMap(resourceData, size, startPositions) {
            const canvas = document.getElementById('resourceCanvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 512;
            canvas.height = 512;

            // Clear canvas with dark background
            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(0, 0, 512, 512);

            const scale = 512 / size;
            const playerCount = mapConfig.playerCount;
            const showTerritories = document.getElementById('showTerritories').checked;

            // Define player territory colors (semi-transparent)
            const playerColors = [
                'rgba(255, 100, 100, 0.2)',   // Red
                'rgba(100, 100, 255, 0.2)',   // Blue
                'rgba(100, 255, 100, 0.2)',   // Green
                'rgba(255, 255, 100, 0.2)',   // Yellow
                'rgba(255, 100, 255, 0.2)',   // Magenta
                'rgba(100, 255, 255, 0.2)',   // Cyan
                'rgba(255, 150, 50, 0.2)',    // Orange
                'rgba(150, 50, 255, 0.2)'     // Purple
            ];

            // Define solid player colors for metal spots
            const playerSpotColors = [
                '#ff6464',   // Red
                '#6464ff',   // Blue
                '#64ff64',   // Green
                '#ffff64',   // Yellow
                '#ff64ff',   // Magenta
                '#64ffff',   // Cyan
                '#ff9632',   // Orange
                '#9632ff'    // Purple
            ];

            // Draw territory boundaries (only if checkbox is checked)
            if (showTerritories && resourceData.territories && resourceData.territories.territories) {
                const territories = resourceData.territories.territories;
                const imageData = ctx.createImageData(512, 512);
                const data = imageData.data;

                for (let y = 0; y < 512; y++) {
                    for (let x = 0; x < 512; x++) {
                        const mapX = Math.floor(x / scale);
                        const mapY = Math.floor(y / scale);
                        const index = mapY * size + mapX;
                        const player = territories[index];

                        // Parse the color for this player
                        const colorStr = playerColors[player % playerColors.length];
                        const match = colorStr.match(/rgba?\((\d+),\s*(\d+),\s*(\d+),\s*([\d.]+)\)/);
                        if (match) {
                            const pixelIndex = (y * 512 + x) * 4;
                            data[pixelIndex] = parseInt(match[1]);
                            data[pixelIndex + 1] = parseInt(match[2]);
                            data[pixelIndex + 2] = parseInt(match[3]);
                            data[pixelIndex + 3] = Math.floor(parseFloat(match[4]) * 255);
                        }
                    }
                }

                ctx.putImageData(imageData, 0, 0);

                // Draw territory boundary lines
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.lineWidth = 1;

                for (let y = 1; y < size - 1; y++) {
                    for (let x = 1; x < size - 1; x++) {
                        const index = y * size + x;
                        const currentTerritory = territories[index];

                        // Check if this is a boundary pixel
                        const rightNeighbor = territories[index + 1];
                        const bottomNeighbor = territories[(y + 1) * size + x];

                        if (currentTerritory !== rightNeighbor || currentTerritory !== bottomNeighbor) {
                            const canvasX = Math.floor(x * scale);
                            const canvasY = Math.floor(y * scale);

                            if (currentTerritory !== rightNeighbor) {
                                ctx.beginPath();
                                ctx.moveTo(canvasX, canvasY);
                                ctx.lineTo(canvasX, canvasY + Math.ceil(scale));
                                ctx.stroke();
                            }

                            if (currentTerritory !== bottomNeighbor) {
                                ctx.beginPath();
                                ctx.moveTo(canvasX, canvasY);
                                ctx.lineTo(canvasX + Math.ceil(scale), canvasY);
                                ctx.stroke();
                            }
                        }
                    }
                }
            }

            // Draw metal spots - color by territory/player
            resourceData.metalSpots.forEach(spot => {
                const x = spot.x * scale;
                const y = spot.y * scale;
                ctx.beginPath();
                ctx.arc(x, y, 6, 0, 2 * Math.PI);

                // Use player-specific color for this spot
                const playerColor = playerSpotColors[spot.territory % playerSpotColors.length];
                ctx.fillStyle = playerColor;
                ctx.fill();
            });

            // Draw geo spots
            ctx.fillStyle = '#ff4444';
            resourceData.geoSpots.forEach(spot => {
                const x = spot.x * scale;
                const y = spot.y * scale;
                ctx.beginPath();
                ctx.arc(x, y, 8, 0, 2 * Math.PI);
                ctx.fill();
            });

            // Draw start positions
            ctx.fillStyle = '#44ff44';
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 2;
            startPositions.forEach((pos, index) => {
                const x = pos.x * scale;
                const y = pos.y * scale;
                ctx.beginPath();
                ctx.arc(x, y, 12, 0, 2 * Math.PI);
                ctx.fill();
                ctx.stroke();

                // Draw player number
                ctx.fillStyle = '#000000';
                ctx.font = 'bold 12px Arial';
                ctx.textAlign = 'center';
                ctx.fillText((index + 1).toString(), x, y + 4);
                ctx.fillStyle = '#44ff44';
            });

            // Calculate and display statistics
            const balance = calculateResourceBalance(resourceData, playerCount);

            // Draw statistics overlay panel
            const panelX = 10;
            const panelY = 10;
            const panelWidth = 200;
            const lineHeight = 16;
            const padding = 8;

            // Semi-transparent panel background
            ctx.fillStyle = 'rgba(0, 0, 0, 0.85)';
            ctx.fillRect(panelX, panelY, panelWidth, 140);

            // Panel border
            ctx.strokeStyle = '#ffd700';
            ctx.lineWidth = 2;
            ctx.strokeRect(panelX, panelY, panelWidth, 140);

            // Title
            ctx.fillStyle = '#ffd700';
            ctx.font = 'bold 14px Arial';
            ctx.textAlign = 'left';
            ctx.fillText('Resource Balance', panelX + padding, panelY + 20);

            // Overall fairness score
            const fairness = parseFloat(balance.summary.overallFairness);
            const fairnessColor = fairness >= 80 ? '#44ff44' : fairness >= 60 ? '#ffdd00' : '#ff4444';
            ctx.fillStyle = '#ffffff';
            ctx.font = '12px Arial';
            ctx.fillText(`Balance Score:`, panelX + padding, panelY + 40);
            ctx.fillStyle = fairnessColor;
            ctx.font = 'bold 12px Arial';
            ctx.fillText(`${fairness.toFixed(1)}%`, panelX + padding + 110, panelY + 40);

            // Per-player metal totals
            ctx.fillStyle = '#ffffff';
            ctx.font = '12px Arial';
            ctx.fillText('Metal per Player:', panelX + padding, panelY + 60);

            let y = panelY + 78;
            balance.perPlayer.forEach((player, index) => {
                const colorStr = playerColors[index % playerColors.length];
                const match = colorStr.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)/);
                const rgbColor = match ? `rgb(${match[1]}, ${match[2]}, ${match[3]})` : '#ffffff';

                ctx.fillStyle = rgbColor;
                ctx.font = 'bold 11px Arial';
                ctx.fillText(`P${player.player}:`, panelX + padding, y);

                ctx.fillStyle = '#ffffff';
                ctx.font = '11px Arial';
                ctx.fillText(`${player.totalMetalValue.toFixed(1)} (${player.metalSpotCount} spots)`,
                           panelX + padding + 35, y);
                y += lineHeight;
            });

            // Total metal spots
            ctx.fillStyle = '#aaaaaa';
            ctx.font = '11px Arial';
            ctx.fillText(`Total Metal Spots: ${balance.summary.totalMetalSpots}`,
                       panelX + padding, panelY + 130);

            console.log("Resource map drawn to canvas - NO DOWNLOAD");
        }

        // CONFIGURATION EXPORT/IMPORT FUNCTIONS
        function exportConfigJSON() {
            if (!mapConfig || Object.keys(mapConfig).length === 0) {
                alert('Please generate a map first!');
                return;
            }

            // Collect metadata from form fields
            const creatorName = document.getElementById('creatorName').value.trim() || 'Anonymous';
            const mapDescription = document.getElementById('mapDescription').value.trim() || 'No description';

            // Create export object with all configuration and metadata
            const exportData = {
                version: '1.0',
                timestamp: new Date().toISOString(),
                metadata: {
                    creator: creatorName,
                    description: mapDescription
                },
                config: { ...mapConfig }
            };

            // Convert to JSON string with pretty formatting
            const jsonString = JSON.stringify(exportData, null, 2);

            // Create blob and download
            const blob = new Blob([jsonString], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `map_config_${mapConfig.terrainType}_${mapConfig.size}x${mapConfig.size}_${Date.now()}.json`;
            a.click();
            URL.revokeObjectURL(url);
        }

        function exportConfigText() {
            if (!mapConfig || Object.keys(mapConfig).length === 0) {
                alert('Please generate a map first!');
                return;
            }

            try {
                // Collect metadata from form fields
                const creatorName = document.getElementById('creatorName').value.trim() || 'Anonymous';
                const mapDescription = document.getElementById('mapDescription').value.trim() || 'No description';

                // Create export object with all configuration and metadata
                const exportData = {
                    version: '1.0',
                    timestamp: new Date().toISOString(),
                    metadata: {
                        creator: creatorName,
                        description: mapDescription
                    },
                    config: { ...mapConfig }
                };

                // Convert to JSON string (compact for sharing)
                const jsonString = JSON.stringify(exportData);

                // Encode as base64 for easy copy-paste sharing
                const base64String = btoa(jsonString);

                // Copy to clipboard
                navigator.clipboard.writeText(base64String).then(() => {
                    alert('Configuration copied to clipboard!\n\nYou can now paste this config string to share with others.');
                }).catch(err => {
                    // Fallback for older browsers or when clipboard API fails
                    const textArea = document.createElement('textarea');
                    textArea.value = base64String;
                    textArea.style.position = 'fixed';
                    textArea.style.left = '-999999px';
                    document.body.appendChild(textArea);
                    textArea.select();
                    try {
                        document.execCommand('copy');
                        alert('Configuration copied to clipboard!\n\nYou can now paste this config string to share with others.');
                    } catch (err) {
                        alert('Failed to copy to clipboard. Please check browser permissions.');
                    }
                    document.body.removeChild(textArea);
                });
            } catch (error) {
                alert('Error exporting configuration: ' + error.message);
            }
        }

        // Validation function for configuration values
        function validateConfigurationValues(config) {
            // Valid map sizes
            const validMapSizes = ['512', '1024', '2048'];
            const validTerrainTypes = ['continental', 'islands', 'canyon', 'hills', 'flat'];
            const validPlayerCounts = ['2', '4', '6', '8'];

            // Validate mapSize
            if (config.size !== undefined) {
                if (typeof config.size !== 'string' && typeof config.size !== 'number') {
                    throw new Error('Invalid configuration: map size must be a string or number.');
                }
                const sizeStr = String(config.size);
                if (!validMapSizes.includes(sizeStr)) {
                    throw new Error('Invalid configuration: map size must be 512, 1024, or 2048. Got: ' + sizeStr);
                }
            }

            // Validate terrainType
            if (config.terrainType !== undefined) {
                if (typeof config.terrainType !== 'string') {
                    throw new Error('Invalid configuration: terrain type must be a string.');
                }
                if (!validTerrainTypes.includes(config.terrainType)) {
                    throw new Error('Invalid configuration: terrain type must be one of: ' + validTerrainTypes.join(', ') + '. Got: ' + config.terrainType);
                }
            }

            // Validate playerCount
            if (config.playerCount !== undefined) {
                if (typeof config.playerCount !== 'string' && typeof config.playerCount !== 'number') {
                    throw new Error('Invalid configuration: player count must be a string or number.');
                }
                const playerStr = String(config.playerCount);
                if (!validPlayerCounts.includes(playerStr)) {
                    throw new Error('Invalid configuration: player count must be 2, 4, 6, or 8. Got: ' + playerStr);
                }
            }

            // Validate numeric ranges
            const numericFields = [
                { name: 'noiseStrength', min: 0, max: 1 },
                { name: 'heightVariation', min: 0, max: 1 },
                { name: 'waterLevel', min: 0, max: 1 },
                { name: 'metalSpots', min: 0, max: 100 },
                { name: 'metalStrength', min: 0, max: 1 },
                { name: 'geoSpots', min: 0, max: 50 }
            ];

            for (const field of numericFields) {
                if (config[field.name] !== undefined) {
                    const value = Number(config[field.name]);
                    if (isNaN(value)) {
                        throw new Error('Invalid configuration: ' + field.name + ' must be a valid number. Got: ' + config[field.name]);
                    }
                    if (value < field.min || value > field.max) {
                        throw new Error('Invalid configuration: ' + field.name + ' must be between ' + field.min + ' and ' + field.max + '. Got: ' + value);
                    }
                }
            }
        }

        function importConfigFromFile() {
            const fileInput = document.getElementById('configFileInput');
            const file = fileInput.files[0];
            importConfigFromJSON(file);

            // Clear the file input after import
            fileInput.value = '';
        }

        function importConfigFromJSON(file) {
            if (!file) {
                alert('Please select a JSON file to import!');
                return;
            }

            const reader = new FileReader();

            reader.onload = function(e) {
                try {
                    const jsonContent = e.target.result;

                    // Check if file is empty
                    if (!jsonContent || jsonContent.trim() === '') {
                        throw new Error('The file is empty. Please select a valid configuration file.');
                    }

                    // Try to parse JSON
                    let importData;
                    try {
                        importData = JSON.parse(jsonContent);
                    } catch (parseError) {
                        if (parseError instanceof SyntaxError) {
                            throw new Error('The file is not valid JSON.\n\nDetails: ' + parseError.message);
                        }
                        throw parseError;
                    }

                    // Validate structure
                    if (!importData || typeof importData !== 'object') {
                        throw new Error('Invalid configuration file format. The content must be a valid JSON object.');
                    }

                    if (!importData.version || !importData.config) {
                        throw new Error('Invalid configuration file format. Missing required fields (version or config).');
                    }

                    // Validate version is a string
                    if (typeof importData.version !== 'string') {
                        throw new Error('Invalid configuration file format. Version must be a string.');
                    }

                    // Check version compatibility
                    if (importData.version !== '1.0') {
                        alert('Warning: This configuration was created with a different version (v' + importData.version + '). Some settings may not work correctly.');
                    }

                    // Validate config is an object
                    if (typeof importData.config !== 'object' || importData.config === null) {
                        throw new Error('Invalid configuration file format. Config must be a valid object.');
                    }

                    const config = importData.config;

                    // Validate configuration values
                    validateConfigurationValues(config);

                    // Apply all configuration values to form elements
                    if (config.size !== undefined) {
                        document.getElementById('mapSize').value = config.size;
                    }
                    if (config.terrainType !== undefined) {
                        document.getElementById('terrainType').value = config.terrainType;
                    }
                    if (config.playerCount !== undefined) {
                        document.getElementById('playerCount').value = config.playerCount;
                    }
                    if (config.noiseStrength !== undefined) {
                        document.getElementById('noiseStrength').value = config.noiseStrength;
                    }
                    if (config.heightVariation !== undefined) {
                        document.getElementById('heightVariation').value = config.heightVariation;
                    }
                    if (config.waterLevel !== undefined) {
                        document.getElementById('waterLevel').value = config.waterLevel;
                    }
                    if (config.metalSpots !== undefined) {
                        document.getElementById('metalSpots').value = config.metalSpots;
                    }
                    if (config.metalStrength !== undefined) {
                        document.getElementById('metalStrength').value = config.metalStrength;
                    }
                    if (config.geoSpots !== undefined) {
                        document.getElementById('geoSpots').value = config.geoSpots;
                    }

                    // Apply metadata
                    if (importData.metadata) {
                        if (importData.metadata.creator) {
                            document.getElementById('creatorName').value = importData.metadata.creator;
                        }
                        if (importData.metadata.description) {
                            document.getElementById('mapDescription').value = importData.metadata.description;
                        }
                    }

                    // Update value displays
                    updateValueDisplays();

                    // Update mapConfig object
                    mapConfig = { ...config };

                    // Show success message with details
                    const timestamp = importData.timestamp ? new Date(importData.timestamp).toLocaleString() : 'Unknown';
                    alert('Configuration imported successfully!\n\n' +
                          'Creator: ' + (importData.metadata?.creator || 'Anonymous') + '\n' +
                          'Description: ' + (importData.metadata?.description || 'No description') + '\n' +
                          'Exported: ' + timestamp + '\n\n' +
                          'Click "Generate Map" to generate the map with these settings.');

                } catch (error) {
                    // Errors are already well-formatted in the try block, just display them
                    alert('Error importing configuration: ' + error.message);
                }
            };

            reader.onerror = function() {
                alert('Error reading file: Please try again with a different file.');
            };

            // Read the file as text
            reader.readAsText(file);
        }

        function importConfigFromText() {
            const textArea = document.getElementById('configTextInput');
            const base64String = textArea.value.trim();

            if (!base64String) {
                alert('Please paste a configuration string into the text area first!');
                return;
            }

            try {
                // Check if the string might be empty
                if (base64String.length === 0) {
                    throw new Error('The configuration string is empty.');
                }

                // Decode base64 string
                let jsonString;
                try {
                    jsonString = atob(base64String);
                } catch (decodeError) {
                    if (decodeError.name === 'InvalidCharacterError') {
                        throw new Error('The configuration string contains invalid characters.\n\nThis usually means:\n- The string was not copied completely\n- Extra spaces or line breaks were added\n- It\'s not a valid base64-encoded string');
                    }
                    throw decodeError;
                }

                // Check if decoded JSON is empty
                if (!jsonString || jsonString.trim() === '') {
                    throw new Error('The decoded configuration is empty. The configuration string may be corrupted.');
                }

                // Parse JSON
                let importData;
                try {
                    importData = JSON.parse(jsonString);
                } catch (parseError) {
                    if (parseError instanceof SyntaxError) {
                        throw new Error('The configuration string is not valid JSON after decoding.\n\nDetails: ' + parseError.message + '\n\nPlease make sure you copied the complete configuration string.');
                    }
                    throw parseError;
                }

                // Validate structure
                if (!importData || typeof importData !== 'object') {
                    throw new Error('Invalid configuration format. The content must be a valid JSON object.');
                }

                if (!importData.version || !importData.config) {
                    throw new Error('Invalid configuration format. Missing required fields (version or config).');
                }

                // Validate version is a string
                if (typeof importData.version !== 'string') {
                    throw new Error('Invalid configuration format. Version must be a string.');
                }

                // Check version compatibility
                if (importData.version !== '1.0') {
                    alert('Warning: This configuration was created with a different version (v' + importData.version + '). Some settings may not work correctly.');
                }

                // Validate config is an object
                if (typeof importData.config !== 'object' || importData.config === null) {
                    throw new Error('Invalid configuration format. Config must be a valid object.');
                }

                const config = importData.config;

                // Validate configuration values
                validateConfigurationValues(config);

                // Apply all configuration values to form elements
                if (config.size !== undefined) {
                    document.getElementById('mapSize').value = config.size;
                }
                if (config.terrainType !== undefined) {
                    document.getElementById('terrainType').value = config.terrainType;
                }
                if (config.playerCount !== undefined) {
                    document.getElementById('playerCount').value = config.playerCount;
                }
                if (config.noiseStrength !== undefined) {
                    document.getElementById('noiseStrength').value = config.noiseStrength;
                }
                if (config.heightVariation !== undefined) {
                    document.getElementById('heightVariation').value = config.heightVariation;
                }
                if (config.waterLevel !== undefined) {
                    document.getElementById('waterLevel').value = config.waterLevel;
                }
                if (config.metalSpots !== undefined) {
                    document.getElementById('metalSpots').value = config.metalSpots;
                }
                if (config.metalStrength !== undefined) {
                    document.getElementById('metalStrength').value = config.metalStrength;
                }
                if (config.geoSpots !== undefined) {
                    document.getElementById('geoSpots').value = config.geoSpots;
                }

                // Apply metadata
                if (importData.metadata) {
                    if (importData.metadata.creator) {
                        document.getElementById('creatorName').value = importData.metadata.creator;
                    }
                    if (importData.metadata.description) {
                        document.getElementById('mapDescription').value = importData.metadata.description;
                    }
                }

                // Update value displays
                updateValueDisplays();

                // Update mapConfig object
                mapConfig = { ...config };

                // Show success message with details
                const timestamp = importData.timestamp ? new Date(importData.timestamp).toLocaleString() : 'Unknown';
                alert('Configuration imported successfully!\n\n' +
                      'Creator: ' + (importData.metadata?.creator || 'Anonymous') + '\n' +
                      'Description: ' + (importData.metadata?.description || 'No description') + '\n' +
                      'Exported: ' + timestamp + '\n\n' +
                      'Click "Generate Map" to generate the map with these settings.');

                // Clear the textarea after successful import
                textArea.value = '';

            } catch (error) {
                // Errors are already well-formatted in the try block, just display them
                alert('Error importing configuration: ' + error.message);
            }
        }

        // COMPLETE BAR MAP PACKAGE GENERATION
        async function downloadCompleteMapPackage() {
            if (!heightmapData) {
                alert('Please generate a map first!');
                return;
            }
            
            const mapName = `generated_${mapConfig.terrainType}_${mapConfig.size}x${mapConfig.size}`;
            console.log("Generating complete BAR map package:", mapName);
            
            try {
                // Generate all BAR assets
                const barAssets = generateBARAssets();
                
                // Generate build scripts
                const buildScripts = generateBuildScripts(mapName);
                
                // Create ZIP file with complete self-compiling package
                const zipBlob = await createCompleteMapPackage(barAssets, buildScripts, mapName);
                
                // Download
                const url = URL.createObjectURL(zipBlob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `${mapName}_complete_package.zip`;
                a.click();
                URL.revokeObjectURL(url);
                
                console.log("Complete BAR map package generated successfully!");
            } catch (error) {
                console.error("Error generating BAR map package:", error);
                alert("Error generating BAR map package: " + error.message);
            }
        }
        
        function generateBuildScripts(mapName) {
            const pythonScript = generatePythonBuildScript(mapName);
            const batchScript = generateBatchScript(mapName);
            const bashScript = generateBashScript(mapName);
            const requirements = generateRequirements();
            const readme = generateDetailedReadme(mapName);
            
            return {
                python: pythonScript,
                batch: batchScript,
                bash: bashScript,
                requirements: requirements,
                readme: readme
            };
        }
        
        function generatePythonBuildScript(mapName) {
            return `#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
BAR Map Builder - Automatischer Map-Kompiler
Generiert von BAR Map Generator v1.0

Dieser Script kompiliert automatisch alle generierten Assets 
in eine vollst√§ndige, spielbare BAR Map.
"""

import os
import sys
import subprocess
import urllib.request
import zipfile
import shutil
from pathlib import Path

# Konfiguration
MAP_NAME = "${mapName}"
TOOLS_DIR = "tools"
OUTPUT_DIR = "output"
ASSETS_DIR = "assets"

# PyMapConv URLs (Beherith's modern map compiler)
PYMAPCONV_URLS = {
    "windows": "https://github.com/Beherith/springrts_smf_compiler/releases/latest/download/pymapconv.exe",
    "linux": "https://github.com/Beherith/springrts_smf_compiler/releases/download/v0.6.3/pymapconv.v0.6.3.linux-amd64.tar.gz"
}

def print_banner():
    print("=" * 60)
    print("üó∫Ô∏è  BAR Map Builder")
    print("   Kompiliert: " + MAP_NAME)
    print("=" * 60)

def detect_os():
    if sys.platform.startswith('win'):
        return 'windows'
    elif sys.platform.startswith('linux'):
        return 'linux'
    else:
        print("‚ùå Unsupported OS:", sys.platform)
        return None

def download_tools(os_type):
    """Download and extract PyMapConv"""
    print("üì• Lade PyMapConv herunter...")
    
    if not os.path.exists(TOOLS_DIR):
        os.makedirs(TOOLS_DIR)
    
    url = PYMAPCONV_URLS.get(os_type)
    if not url:
        print("‚ùå Keine Tools f√ºr dein OS verf√ºgbar")
        return False
    
    filename = url.split('/')[-1]
    filepath = os.path.join(TOOLS_DIR, filename)
    
    try:
        print(f"üîó Downloade von: {url}")
        urllib.request.urlretrieve(url, filepath)
        print(f"‚úÖ {filename} heruntergeladen")
        
        # Extract for Linux (release tarball) 
        if filename.endswith('.tar.gz') and os_type == 'linux':
            import tarfile
            with tarfile.open(filepath, 'r:gz') as tar_ref:
                tar_ref.extractall(TOOLS_DIR)
            print("‚úÖ PyMapConv Linux Release extrahiert")
            
            # Make executable
            pymapconv_executable = os.path.join(TOOLS_DIR, "pymapconv")
            if os.path.exists(pymapconv_executable):
                os.chmod(pymapconv_executable, 0o755)
                print("‚úÖ PyMapConv ausf√ºhrbar gemacht")
            
            # Install Linux dependencies
            install_linux_dependencies()
            
        elif filename.endswith('.zip') and os_type == 'linux':
            # Fallback to source if release not available
            with zipfile.ZipFile(filepath, 'r') as zip_ref:
                zip_ref.extractall(TOOLS_DIR)
            print("‚úÖ PyMapConv Quellcode extrahiert (Fallback)")
            
            # Install Python dependencies
            requirements_path = os.path.join(TOOLS_DIR, "springrts_smf_compiler-master", "src", "requirements.txt")
            if os.path.exists(requirements_path):
                print("üì¶ Installiere Python-Abh√§ngigkeiten...")
                install_success = install_python_dependencies(requirements_path)
                if not install_success:
                    print("‚ö†Ô∏è  Abh√§ngigkeiten-Installation fehlgeschlagen")
                    print("   Installiere manuell mit: pip install -r " + requirements_path)
            else:
                print("üì¶ Installiere Standard-Abh√§ngigkeiten...")
                install_success = install_standard_dependencies()
                if not install_success:
                    print("‚ö†Ô∏è  Standard-Abh√§ngigkeiten nicht installiert")
                    
            # Install Linux dependencies
            install_linux_dependencies()
            
        elif os_type == 'windows':
            print("‚úÖ PyMapConv executable bereit")
        
        return True
        
    except Exception as e:
        print(f"‚ùå Fehler beim Herunterladen: {e}")
        print(f"   URL: {url}")
        return False

def install_python_dependencies(requirements_path):
    """Install Python dependencies from requirements.txt"""
    try:
        print(f"üìã Lese Abh√§ngigkeiten aus: {requirements_path}")
        
        # Try creating virtual environment first
        venv_success = create_virtual_environment()
        if venv_success:
            pip_executable = os.path.join("venv", "bin", "pip")
            if os.name == 'nt':  # Windows
                pip_executable = os.path.join("venv", "Scripts", "pip.exe")
        else:
            pip_executable = sys.executable
            pip_command = [pip_executable, "-m", "pip", "install", "-r", requirements_path]
            
            # Try with --break-system-packages flag if regular install fails
            result = subprocess.run(pip_command, capture_output=True, text=True, timeout=300)
            if result.returncode != 0 and "externally-managed-environment" in result.stderr:
                print("üîß Verwende --break-system-packages flag...")
                pip_command.append("--break-system-packages")
                result = subprocess.run(pip_command, capture_output=True, text=True, timeout=300)
        
        if venv_success:
            result = subprocess.run([pip_executable, "install", "-r", requirements_path], 
                                  capture_output=True, text=True, timeout=300)
        
        if result.returncode == 0:
            print("‚úÖ Abh√§ngigkeiten aus requirements.txt installiert")
            return True
        else:
            print("‚ùå pip install fehlgeschlagen:")
            print(result.stderr)
            return False
    except subprocess.TimeoutExpired:
        print("‚ùå pip install Timeout")
        return False
    except Exception as e:
        print(f"‚ùå Fehler bei pip install: {e}")
        return False

def create_virtual_environment():
    """Create a virtual environment for Python dependencies"""
    venv_path = "venv"
    
    if os.path.exists(venv_path):
        print("üìÅ Virtuelle Umgebung bereits vorhanden")
        return True
    
    try:
        print("üîß Erstelle virtuelle Python-Umgebung...")
        result = subprocess.run([sys.executable, "-m", "venv", venv_path], 
                              capture_output=True, text=True, timeout=60)
        if result.returncode == 0:
            print("‚úÖ Virtuelle Umgebung erstellt")
            return True
        else:
            print("‚ùå Virtuelle Umgebung konnte nicht erstellt werden:")
            print(result.stderr)
            return False
    except Exception as e:
        print(f"‚ùå Fehler beim Erstellen der virtuellen Umgebung: {e}")
        return False

def create_minimal_geovent(geovent_path):
    """Create a minimal geovent.bmp file for PyMapConv"""
    try:
        from PIL import Image
        # Create a simple 32x32 black image for geovent
        img = Image.new('L', (32, 32), 0)  # Grayscale, black
        img.save(geovent_path, 'BMP')
        print(f"‚úÖ Minimal geovent.bmp erstellt: {geovent_path}")
    except Exception as e:
        print(f"‚ö†Ô∏è  Konnte geovent.bmp nicht erstellen: {e}")
        # Create empty file as fallback
        with open(geovent_path, 'w') as f:
            f.write("")

def fix_asset_formats():
    """Fix asset file formats for PyMapConv compatibility"""
    try:
        from PIL import Image
        
        # Fix texture.bmp - remove alpha channel
        texture_path = os.path.join(ASSETS_DIR, "texture.bmp")
        if os.path.exists(texture_path):
            print("   üîß Korrigiere texture.bmp (entferne Alpha-Kanal)...")
            img = Image.open(texture_path)
            if img.mode in ('RGBA', 'LA'):
                # Convert to RGB without alpha
                rgb_img = Image.new('RGB', img.size, (255, 255, 255))
                if img.mode == 'RGBA':
                    rgb_img.paste(img, mask=img.split()[-1])  # Use alpha as mask
                else:
                    rgb_img.paste(img.convert('RGB'))
                rgb_img.save(texture_path, 'BMP')
                print("   ‚úÖ Texture.bmp Alpha-Kanal entfernt")
        
        # Fix heightmap.bmp - ensure RGB format (PyMapConv needs RGB, not grayscale)
        heightmap_path = os.path.join(ASSETS_DIR, "heightmap.bmp")
        if os.path.exists(heightmap_path):
            print("   üîß Korrigiere heightmap.bmp (RGB-Format f√ºr PyMapConv)...")
            img = Image.open(heightmap_path)
            if img.mode != 'RGB':
                # Convert to RGB - PyMapConv needs RGB channels
                if img.mode == 'L':
                    # Grayscale to RGB: copy grayscale value to all channels
                    rgb_img = Image.new('RGB', img.size)
                    pixels = list(img.getdata())
                    rgb_pixels = [(p, p, p) for p in pixels]
                    rgb_img.putdata(rgb_pixels)
                elif img.mode == 'RGBA':
                    # RGBA to RGB: blend with white background
                    rgb_img = Image.new('RGB', img.size, (255, 255, 255))
                    rgb_img.paste(img, mask=img.split()[-1])
                else:
                    rgb_img = img.convert('RGB')
                rgb_img.save(heightmap_path, 'BMP')
                print("   ‚úÖ Heightmap.bmp zu RGB konvertiert (PyMapConv-kompatibel)")
        
        # Fix grassmap dimensions (must be 256x256 for 16x16 map units)
        grassmap_path = os.path.join(ASSETS_DIR, "grassmap.bmp")
        if os.path.exists(grassmap_path):
            print("   üîß Korrigiere grassmap.bmp (256x256 Gr√∂√üe)...")
            img = Image.open(grassmap_path)
            if img.size != (256, 256):
                resized_img = img.resize((256, 256), Image.NEAREST)
                # Remove alpha if present and ensure RGB format
                if resized_img.mode in ('RGBA', 'LA'):
                    rgb_img = Image.new('RGB', resized_img.size, (0, 0, 0))
                    if resized_img.mode == 'RGBA':
                        rgb_img.paste(resized_img, mask=resized_img.split()[-1])
                    else:
                        rgb_img = resized_img.convert('RGB')
                    resized_img = rgb_img
                elif resized_img.mode == 'L':
                    # Convert grayscale to RGB
                    resized_img = resized_img.convert('RGB')
                resized_img.save(grassmap_path, 'BMP')
                print("   ‚úÖ Grassmap.bmp auf 256x256 skaliert und RGB-Format")
        
        # Fix typemap dimensions (must be 512x512 for 16x16 map units)
        typemap_path = os.path.join(ASSETS_DIR, "typemap.bmp")
        if os.path.exists(typemap_path):
            print("   üîß Korrigiere typemap.bmp (512x512 Gr√∂√üe)...")
            img = Image.open(typemap_path)
            if img.size != (512, 512):
                resized_img = img.resize((512, 512), Image.NEAREST)
                # Remove alpha if present
                if resized_img.mode in ('RGBA', 'LA'):
                    rgb_img = Image.new('RGB', resized_img.size, (0, 0, 0))
                    if resized_img.mode == 'RGBA':
                        rgb_img.paste(resized_img, mask=resized_img.split()[-1])
                    else:
                        rgb_img = resized_img.convert('RGB')
                    resized_img = rgb_img
                resized_img.save(typemap_path, 'BMP')
                print("   ‚úÖ Typemap.bmp auf 512x512 skaliert")
        
        # Fix metalmap dimensions (must be 512x512 for 16x16 map units)
        metalmap_path = os.path.join(ASSETS_DIR, "metalmap.bmp")
        if os.path.exists(metalmap_path):
            print("   üîß Korrigiere metalmap.bmp (512x512 Gr√∂√üe)...")
            img = Image.open(metalmap_path)
            if img.size != (512, 512):
                resized_img = img.resize((512, 512), Image.NEAREST)
                # Remove alpha if present and convert to grayscale
                if resized_img.mode in ('RGBA', 'LA'):
                    # For metalmap, use red channel only
                    if resized_img.mode == 'RGBA':
                        r, g, b, a = resized_img.split()
                        resized_img = r  # Use red channel for metal values
                    else:
                        resized_img = resized_img.convert('L')
                elif resized_img.mode == 'RGB':
                    # Use red channel
                    r, g, b = resized_img.split()
                    resized_img = r
                resized_img.save(metalmap_path, 'BMP')
                print("   ‚úÖ Metalmap.bmp auf 512x512 skaliert und zu Grayscale konvertiert")
        
        # Fix minimap - remove alpha channel  
        minimap_path = os.path.join(ASSETS_DIR, "minimap.png")
        if os.path.exists(minimap_path):
            print("   üîß Korrigiere minimap.png (entferne Alpha-Kanal)...")
            img = Image.open(minimap_path)
            if img.mode in ('RGBA', 'LA'):
                # Convert to RGB without alpha
                rgb_img = Image.new('RGB', img.size, (255, 255, 255))
                if img.mode == 'RGBA':
                    rgb_img.paste(img, mask=img.split()[-1])  # Use alpha as mask
                else:
                    rgb_img.paste(img.convert('RGB'))
                rgb_img.save(minimap_path, 'PNG')
                print("   ‚úÖ Minimap.png Alpha-Kanal entfernt")
        
        print("‚úÖ Asset-Formate korrigiert")
        
    except Exception as e:
        print(f"‚ö†Ô∏è  Asset-Format-Korrektur fehlgeschlagen: {e}")
        print("   Verwende Original-Assets...")

def install_linux_dependencies():
    """Install Linux-specific dependencies for PyMapConv"""
    print("üîß Installiere Linux-Abh√§ngigkeiten...")
    
    # Check for ImageMagick
    try:
        result = subprocess.run(["convert", "-version"], capture_output=True, text=True, timeout=10)
        if result.returncode == 0:
            print("‚úÖ ImageMagick bereits verf√ºgbar")
        else:
            print("‚ö†Ô∏è  ImageMagick nicht gefunden - installiere mit deinem Package Manager:")
            print("   Ubuntu/Debian: sudo apt install imagemagick")
            print("   Arch/Manjaro: sudo pacman -S imagemagick") 
            print("   Fedora: sudo dnf install ImageMagick")
    except:
        print("‚ö†Ô∏è  ImageMagick nicht verf√ºgbar - wird f√ºr Texture-Konvertierung ben√∂tigt")
    
    # Try to install CompressonatorCLI
    install_compressonator()

def install_compressonator():
    """Install CompressonatorCLI if needed"""
    try:
        # Check if CompressonatorCLI is already available
        result = subprocess.run(["CompressonatorCLI", "--help"], 
                              capture_output=True, text=True, timeout=10)
        if result.returncode == 0:
            print("‚úÖ CompressonatorCLI bereits verf√ºgbar")
            return True
    except:
        pass
    
    print("üì• Versuche CompressonatorCLI Installation...")
    
    # Try AppImage version first (more universal)
    appimage_url = "https://github.com/GPUOpen-Tools/compressonator/releases/download/V4.4.13/compressonator-4.4.13-x86_64.AppImage"
    
    try:
        filename = "compressonator.AppImage"
        filepath = os.path.join(TOOLS_DIR, filename)
        
        urllib.request.urlretrieve(appimage_url, filepath)
        print("‚úÖ CompressonatorCLI AppImage heruntergeladen")
        
        # Make executable
        os.chmod(filepath, 0o755)
        
        # Test if it works
        result = subprocess.run([filepath, "--help"], capture_output=True, text=True, timeout=15)
        if result.returncode == 0:
            print("‚úÖ CompressonatorCLI AppImage funktioniert")
            return True
        else:
            print("‚ö†Ô∏è  CompressonatorCLI AppImage Test fehlgeschlagen")
            return False
            
    except Exception as e:
        print(f"‚ö†Ô∏è  CompressonatorCLI Installation fehlgeschlagen: {e}")
        print("   PyMapConv wird ohne Texture-Kompression fortfahren")
        print("   Installiere manuell: https://github.com/GPUOpen-Tools/compressonator")
        return False

def install_standard_dependencies():
    """Install known PyMapConv dependencies manually"""
    dependencies = [
        "pypng",        # png module
        "Pillow",       # PIL/Image processing
        "numpy",        # numerical operations
        "gooey",        # GUI framework
    ]
    
    print(f"üì¶ Installiere bekannte Abh√§ngigkeiten: {', '.join(dependencies)}")
    
    # Try creating virtual environment first
    venv_success = create_virtual_environment()
    if venv_success:
        pip_executable = os.path.join("venv", "bin", "pip")
        if os.name == 'nt':  # Windows
            pip_executable = os.path.join("venv", "Scripts", "pip.exe")
    else:
        pip_executable = sys.executable
    
    all_success = True
    for dep in dependencies:
        try:
            print(f"   üì• Installiere {dep}...")
            
            if venv_success:
                cmd = [pip_executable, "install", dep]
            else:
                cmd = [pip_executable, "-m", "pip", "install", dep]
                
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=120)
            
            # Try with --break-system-packages if needed
            if result.returncode != 0 and "externally-managed-environment" in result.stderr and not venv_success:
                print(f"   üîß Verwende --break-system-packages f√ºr {dep}...")
                cmd.append("--break-system-packages")
                result = subprocess.run(cmd, capture_output=True, text=True, timeout=120)
            
            if result.returncode == 0:
                print(f"   ‚úÖ {dep} installiert")
            else:
                print(f"   ‚ùå {dep} Installation fehlgeschlagen: {result.stderr}")
                all_success = False
        except Exception as e:
            print(f"   ‚ùå Fehler bei {dep}: {e}")
            all_success = False
    
    if all_success:
        print("‚úÖ Alle Standard-Abh√§ngigkeiten installiert")
    else:
        print("‚ö†Ô∏è  Einige Abh√§ngigkeiten konnten nicht installiert werden")
    
    return all_success

def find_pymapconv():
    """Find PyMapConv executable or script"""
    possible_paths = [
        # Windows executable
        os.path.join(TOOLS_DIR, "pymapconv.exe"),
        # Linux release executable
        os.path.join(TOOLS_DIR, "pymapconv"),
        # Linux Python script (fallback)
        os.path.join(TOOLS_DIR, "springrts_smf_compiler-master", "src", "pymapconv.py"),
        # Alternative paths
        os.path.join(TOOLS_DIR, "src", "pymapconv.py"),
        os.path.join(TOOLS_DIR, "pymapconv.py"),
    ]
    
    # Recursively search in tools directory
    for root, dirs, files in os.walk(TOOLS_DIR):
        for file in files:
            if file.lower() in ['pymapconv.exe', 'pymapconv.py', 'pymapconv']:
                possible_paths.append(os.path.join(root, file))
    
    for path in possible_paths:
        if os.path.exists(path):
            return path
    
    return None

def run_pymapconv(pymapconv_path):
    """Run PyMapConv to compile the map"""
    print("üî® Kompiliere Map mit PyMapConv...")
    
    if not os.path.exists(OUTPUT_DIR):
        os.makedirs(OUTPUT_DIR)
    
    # Create temp directories that PyMapConv needs with proper permissions
    temp_dirs = ["temp", "temp/thread0", "temp/thread1", "temp/thread2", "temp/thread3"]
    for temp_dir in temp_dirs:
        if os.path.exists(temp_dir):
            # Clean existing temp directory
            import shutil
            shutil.rmtree(temp_dir, ignore_errors=True)
        
        os.makedirs(temp_dir, mode=0o755)
        print(f"üìÅ Erstellt: {temp_dir}")
        # Ensure directory is writable
        os.chmod(temp_dir, 0o755)
        
        # Test write access and create dummy files to prevent FileNotFoundError
        test_file = os.path.join(temp_dir, "test.tmp")
        try:
            with open(test_file, 'w') as f:
                f.write("test")
            os.remove(test_file)
            print(f"‚úÖ Schreibzugriff best√§tigt: {temp_dir}")
            
            # Pre-create some dummy files to prevent PyMapConv FileNotFoundError
            for i in range(10):
                dummy_file = os.path.join(temp_dir, f"temp{i}.BMP")
                dummy_file2 = os.path.join(temp_dir, f"temp{i}.TIFF")
                try:
                    with open(dummy_file, 'w') as f:
                        f.write("")
                    with open(dummy_file2, 'w') as f:
                        f.write("")
                except:
                    pass
                    
        except Exception as e:
            print(f"‚ö†Ô∏è  Schreibzugriff-Problem in {temp_dir}: {e}")
    
    # Fix asset files before compilation
    print("üîß Korrigiere Asset-Formate...")
    fix_asset_formats()
    
    # Create minimal geovent.bmp if it doesn't exist
    resources_dir = "resources"
    if not os.path.exists(resources_dir):
        os.makedirs(resources_dir, mode=0o755)
    
    geovent_path = os.path.join(resources_dir, "geovent.bmp")
    if not os.path.exists(geovent_path):
        create_minimal_geovent(geovent_path)
    
    # Determine if we're using executable or Python script
    is_python_script = pymapconv_path.endswith('.py')
    is_executable = pymapconv_path.endswith(('pymapconv.exe', 'pymapconv'))
    
    # PyMapConv command - uses GUI mode with batch file input
    output_path = os.path.join(OUTPUT_DIR, MAP_NAME + ".sd7")
    
    if is_python_script:
        # Check if virtual environment exists
        venv_python = os.path.join("venv", "bin", "python")
        if os.name == 'nt':  # Windows
            venv_python = os.path.join("venv", "Scripts", "python.exe")
        
        if os.path.exists(venv_python):
            python_executable = venv_python
            print("üêç Verwende virtuelle Umgebung")
        else:
            python_executable = sys.executable
            print("üêç Verwende System-Python")
        
        # Python script mode - using correct PyMapConv parameters with proper file formats
        cmd = [
            python_executable, pymapconv_path,
            "-a", os.path.join(ASSETS_DIR, "heightmap.bmp"),  # -a HEIGHTMAP (BMP, 8-bit acceptable)
            "-m", os.path.join(ASSETS_DIR, "metalmap.bmp"),   # -m METALMAP (BMP format)
            "-t", os.path.join(ASSETS_DIR, "texture.bmp"),    # -t INTEX (BMP format)
            "-l", os.path.join(ASSETS_DIR, "normalmap.png"),  # -l MAPNORMALS (PNG is ok)
            "-z", os.path.join(ASSETS_DIR, "specularmap.png"), # -z SPECULAR (PNG is ok)
            "-p", os.path.join(ASSETS_DIR, "minimap.png"),    # -p MINIMAP (PNG is ok)
            "-r", os.path.join(ASSETS_DIR, "grassmap.bmp"),   # -r GRASSMAP (BMP format)
            "-y", os.path.join(ASSETS_DIR, "typemap.bmp"),    # -y TYPEMAP (BMP format)
            "-o", output_path                                 # -o OUTFILE
        ]
    elif is_executable:
        # Linux/Windows executable mode - using correct PyMapConv parameters with proper file formats
        cmd = [
            pymapconv_path,
            "-a", os.path.join(ASSETS_DIR, "heightmap.bmp"),  # -a HEIGHTMAP (BMP, RGB format)
            "-m", os.path.join(ASSETS_DIR, "metalmap.bmp"),   # -m METALMAP (BMP format)
            "-t", os.path.join(ASSETS_DIR, "texture.bmp"),    # -t INTEX (BMP format)
            "-l", os.path.join(ASSETS_DIR, "normalmap.png"),  # -l MAPNORMALS (PNG is ok)
            "-z", os.path.join(ASSETS_DIR, "specularmap.png"), # -z SPECULAR (PNG is ok)
            "-p", os.path.join(ASSETS_DIR, "minimap.png"),    # -p MINIMAP (PNG is ok)
            "-r", os.path.join(ASSETS_DIR, "grassmap.bmp"),   # -r GRASSMAP (BMP format)
            "-y", os.path.join(ASSETS_DIR, "typemap.bmp"),    # -y TYPEMAP (BMP format)
            "--numthreads", "1",                              # Single thread to avoid temp file issues
            "-o", output_path                                 # -o OUTFILE
        ]
    else:
        # Unknown format - try as executable
        print("‚ö†Ô∏è  Unbekanntes PyMapConv-Format, versuche als Executable...")
        cmd = [
            pymapconv_path,
            "-a", os.path.join(ASSETS_DIR, "heightmap.bmp"),
            "-m", os.path.join(ASSETS_DIR, "metalmap.bmp"),
            "-t", os.path.join(ASSETS_DIR, "texture.bmp"),
            "-o", output_path
        ]
    
    try:
        print(f"üîß Kommando: {' '.join(cmd)}")
        result = subprocess.run(cmd, capture_output=True, text=True, timeout=300)
        
        if result.returncode == 0:
            print("‚úÖ Map erfolgreich kompiliert!")
            if os.path.exists(output_path):
                print(f"üìÅ Output: {output_path}")
                return True
            else:
                print("‚ö†Ô∏è  PyMapConv erfolgreich, aber Ausgabedatei nicht gefunden")
                return False
        else:
            print("‚ùå PyMapConv Fehler:")
            print("STDOUT:", result.stdout)
            print("STDERR:", result.stderr)
            
            # Try alternative approach - Python script if executable failed
            print("üîÑ Versuche Python-Script als Alternative...")
            python_script_path = find_python_pymapconv()
            if python_script_path:
                print(f"üìç Gefunden: {python_script_path}")
                return run_pymapconv_python(python_script_path)
            else:
                print("üîÑ Lade Python-Version von PyMapConv als Fallback...")
                if download_python_pymapconv():
                    python_script_path = find_python_pymapconv()
                    if python_script_path:
                        print(f"üìç Python-Script gefunden: {python_script_path}")
                        return run_pymapconv_python(python_script_path)
                
                print("üîÑ Versuche vereinfachte Methode...")
                return run_pymapconv_simple(pymapconv_path)
            
    except subprocess.TimeoutExpired:
        print("‚ùå PyMapConv Timeout - Prozess dauerte zu lange")
        return False
    except Exception as e:
        print(f"‚ùå Fehler beim Ausf√ºhren von PyMapConv: {e}")
        return False

def download_python_pymapconv():
    """Download Python version of PyMapConv as fallback"""
    try:
        print("üì• Lade PyMapConv Python-Version herunter...")
        url = "https://github.com/Beherith/springrts_smf_compiler/archive/refs/heads/master.zip"
        filename = "pymapconv_python.zip"
        filepath = os.path.join(TOOLS_DIR, filename)
        
        urllib.request.urlretrieve(url, filepath)
        print("‚úÖ PyMapConv Python-Version heruntergeladen")
        
        # Extract
        with zipfile.ZipFile(filepath, 'r') as zip_ref:
            zip_ref.extractall(TOOLS_DIR)
        print("‚úÖ PyMapConv Python-Quellcode extrahiert")
        
        # Install dependencies
        requirements_path = os.path.join(TOOLS_DIR, "springrts_smf_compiler-master", "src", "requirements.txt")
        if os.path.exists(requirements_path):
            print("üì¶ Installiere Python-Abh√§ngigkeiten...")
            install_python_dependencies(requirements_path)
        else:
            print("üì¶ Installiere Standard-Abh√§ngigkeiten...")
            install_standard_dependencies()
        
        return True
        
    except Exception as e:
        print(f"‚ùå Fehler beim Herunterladen der Python-Version: {e}")
        return False

def find_python_pymapconv():
    """Find Python PyMapConv script as fallback"""
    possible_paths = [
        os.path.join(TOOLS_DIR, "springrts_smf_compiler-master", "src", "pymapconv.py"),
        os.path.join(TOOLS_DIR, "src", "pymapconv.py"),
        os.path.join(TOOLS_DIR, "pymapconv.py"),
    ]
    
    for path in possible_paths:
        if os.path.exists(path):
            return path
    return None

def run_pymapconv_python(pymapconv_path):
    """Run PyMapConv using Python script with virtual environment"""
    print("üêç Verwende PyMapConv Python-Script...")
    
    # Use virtual environment if available
    venv_python = os.path.join("venv", "bin", "python")
    if os.name == 'nt':  # Windows
        venv_python = os.path.join("venv", "Scripts", "python.exe")
    
    if os.path.exists(venv_python):
        python_executable = venv_python
        print("üêç Verwende virtuelle Umgebung")
    else:
        python_executable = sys.executable
        print("üêç Verwende System-Python")
    
    output_path = os.path.join(OUTPUT_DIR, MAP_NAME + ".sd7")
    
    cmd = [
        python_executable, pymapconv_path,
        "-a", os.path.join(ASSETS_DIR, "heightmap.bmp"),  # heightmap
        "-m", os.path.join(ASSETS_DIR, "metalmap.bmp"),   # metalmap
        "-t", os.path.join(ASSETS_DIR, "texture.bmp"),    # texture
        "-l", os.path.join(ASSETS_DIR, "normalmap.png"),  # normalmap
        "-z", os.path.join(ASSETS_DIR, "specularmap.png"), # specular
        "-p", os.path.join(ASSETS_DIR, "minimap.png"),    # minimap
        "-r", os.path.join(ASSETS_DIR, "grassmap.bmp"),   # grassmap
        "-y", os.path.join(ASSETS_DIR, "typemap.bmp"),    # typemap
        "--numthreads", "1",                              # Single thread to avoid temp file issues
        "-o", output_path                                 # output
    ]
    
    try:
        print(f"üîß Python-Kommando: {' '.join(cmd)}")
        result = subprocess.run(cmd, capture_output=True, text=True, timeout=300)
        
        if os.path.exists(output_path):
            print("‚úÖ Map erfolgreich mit Python-Script kompiliert!")
            print(f"üìÅ Output: {output_path}")
            return True
        else:
            print("‚ùå Python-Script Kompilierung fehlgeschlagen")
            print("STDOUT:", result.stdout[-1000:])  # Last 1000 chars
            print("STDERR:", result.stderr[-500:])   # Last 500 chars
            return False
            
    except Exception as e:
        print(f"‚ùå Python-Script Fehler: {e}")
        return False

def run_pymapconv_simple(pymapconv_path):
    """Alternative method using PyMapConv with minimal parameters and skip texture"""
    print("üîÑ Versuche vereinfachte PyMapConv-Kompilierung (ohne Texturen)...")
    
    # Check if virtual environment exists
    is_python_script = pymapconv_path.endswith('.py')
    if is_python_script:
        venv_python = os.path.join("venv", "bin", "python")
        if os.name == 'nt':  # Windows
            venv_python = os.path.join("venv", "Scripts", "python.exe")
        
        if os.path.exists(venv_python):
            python_executable = venv_python
        else:
            python_executable = sys.executable
    
    output_path = os.path.join(OUTPUT_DIR, MAP_NAME + ".sd7")
    
    # Try with only essential parameters and skip texture processing
    if is_python_script:
        cmd = [
            python_executable, pymapconv_path,
            "-a", os.path.join(ASSETS_DIR, "heightmap.bmp"),  # heightmap is essential (BMP, 8-bit acceptable)
            "-m", os.path.join(ASSETS_DIR, "metalmap.bmp"),   # metalmap is essential (BMP format)
            "-s",                                             # skip texture processing
            "-o", output_path                                 # output path
        ]
    else:
        cmd = [
            pymapconv_path,
            "-a", os.path.join(ASSETS_DIR, "heightmap.bmp"),
            "-m", os.path.join(ASSETS_DIR, "metalmap.bmp"),
            "-s",                                             # skip texture processing
            "-o", output_path
        ]
    
    try:
        print(f"üîß Vereinfachtes Kommando: {' '.join(cmd)}")
        result = subprocess.run(cmd, capture_output=True, text=True, timeout=300)
        
        if os.path.exists(output_path):
            print("‚úÖ Map erfolgreich kompiliert (vereinfachte Methode)!")
            print(f"üìÅ Output: {output_path}")
            return True
        else:
            print("‚ùå Vereinfachte PyMapConv-Methode fehlgeschlagen")
            print("STDOUT:", result.stdout)  
            print("STDERR:", result.stderr)
            return False
            
    except Exception as e:
        print(f"‚ùå Vereinfachte Methode fehlgeschlagen: {e}")
        return False

def install_map():
    """Copy compiled map to BAR directory"""
    print("üì• Installiere Map in BAR...")
    
    map_file = os.path.join(OUTPUT_DIR, MAP_NAME + ".sd7")
    if not os.path.exists(map_file):
        print("‚ùå Kompilierte Map nicht gefunden!")
        return False
    
    # BAR map directories
    bar_dirs = [
        os.path.expanduser("~/.var/app/info.beyondallreason.bar/data/maps/"),  # Flatpak
        os.path.expanduser("~/.spring/maps/"),  # Native Linux
        os.path.expanduser("~/Documents/My Games/Spring/maps/"),  # Windows
        os.path.expanduser("~/AppData/Local/Spring/maps/"),  # Windows alternative
    ]
    
    installed = False
    for bar_dir in bar_dirs:
        if os.path.exists(bar_dir):
            try:
                shutil.copy2(map_file, bar_dir)
                print(f"‚úÖ Map installiert in: {bar_dir}")
                installed = True
                break
            except Exception as e:
                print(f"‚ö†Ô∏è  Installation in {bar_dir} fehlgeschlagen: {e}")
    
    if not installed:
        print("‚ö†Ô∏è  Automatische Installation fehlgeschlagen.")
        print(f"üîß Kopiere manuell: {map_file}")
        print("   nach deinen BAR maps Ordner")
    
    return installed

def main():
    print_banner()
    
    # Check if assets exist
    if not os.path.exists(ASSETS_DIR):
        print("‚ùå Assets Ordner nicht gefunden!")
        print("   Stelle sicher, dass du das komplette Paket extrahiert hast.")
        return 1
    
    # Detect OS
    os_type = detect_os()
    if not os_type:
        return 1
    
    # Check for existing PyMapConv
    pymapconv_path = find_pymapconv()
    
    # Download tools if not found
    if not pymapconv_path:
        print("üîç PyMapConv nicht gefunden, lade Tools herunter...")
        if not download_tools(os_type):
            return 1
        pymapconv_path = find_pymapconv()
    
    if not pymapconv_path:
        print("‚ùå PyMapConv konnte nicht gefunden werden!")
        print("   Besuche: https://github.com/Beherith/springrts_smf_compiler")
        return 1
    
    print(f"‚úÖ PyMapConv gefunden: {pymapconv_path}")
    
    # Make executable on Linux
    if os_type == 'linux' and pymapconv_path.endswith('.py'):
        os.chmod(pymapconv_path, 0o755)
    
    # Install CompressonatorCLI for texture compression
    if os_type == 'linux':
        print("üîß Pr√ºfe CompressonatorCLI...")
        install_compressonator()
    
    # Compile map
    if not run_pymapconv(pymapconv_path):
        print("\\n‚ùå PyMapConv Kompilierung fehlgeschlagen!")
        print("\\nüîß M√∂gliche L√∂sungen:")
        print("   1. PyMapConv GUI manuell verwenden:")
        print(f"      cd {os.getcwd()}")
        print(f"      source venv/bin/activate")
        print(f"      python3 {pymapconv_path}")
        print("      ‚Üí Dann: Heightmap=assets/heightmap.bmp, Metalmap=assets/metalmap.bmp")
        print("   2. Installiere Abh√§ngigkeiten manuell:")
        print(f"      pip install pypng Pillow numpy gooey")
        print("   3. Besuche: https://github.com/Beherith/springrts_smf_compiler")
        print("\\nüìÅ Deine Assets sind bereit in: assets/")
        print("üìÑ Map-Konfiguration: mapinfo.lua")
        print("\\nüí° Tipp: PyMapConv hat eine GUI - das k√∂nnte einfacher sein!")
        return 1
    
    # Install map
    install_map()
    
    print("\\nüéâ Map-Generation abgeschlossen!")
    print(f"   Map Name: {MAP_NAME}")
    print(f"   Datei: {os.path.join(OUTPUT_DIR, MAP_NAME + '.sd7')}")
    print("\\nüéÆ Starte BAR und w√§hle deine neue Map aus!")
    
    return 0

if __name__ == "__main__":
    try:
        exit_code = main()
        sys.exit(exit_code)
    except KeyboardInterrupt:
        print("\\n‚ùå Abgebrochen durch Benutzer")
        sys.exit(1)
    except Exception as e:
        print(f"\\n‚ùå Unerwarteter Fehler: {e}")
        sys.exit(1)
`;
        }
        
        function generateBatchScript(mapName) {
            return `@echo off
REM BAR Map Builder - Windows Batch Script
REM Generiert von BAR Map Generator v1.0

echo ============================================================
echo üó∫Ô∏è  BAR Map Builder f√ºr Windows
echo    Kompiliert: ${mapName}
echo ============================================================

REM Check if Python is available
python --version >nul 2>&1
if %errorlevel% neq 0 (
    echo ‚ùå Python nicht gefunden!
    echo    Installiere Python 3.x von https://python.org
    pause
    exit /b 1
)

REM Run Python build script
echo üöÄ Starte Python Build Script...
python build_map.py

if %errorlevel% equ 0 (
    echo.
    echo üéâ Build erfolgreich!
    echo üìÅ Kompilierte Map: output\\${mapName}.sd7
) else (
    echo.
    echo ‚ùå Build fehlgeschlagen!
)

echo.
echo Dr√ºcke eine Taste zum Beenden...
pause >nul
`;
        }
        
        function generateBashScript(mapName) {
            return `#!/bin/bash
# BAR Map Builder - Linux/macOS Bash Script  
# Generiert von BAR Map Generator v1.0

echo "============================================================"
echo "üó∫Ô∏è  BAR Map Builder f√ºr Linux/macOS"
echo "   Kompiliert: ${mapName}"
echo "============================================================"

# Check if Python is available
if ! command -v python3 &> /dev/null; then
    echo "‚ùå Python 3 nicht gefunden!"
    echo "   Installiere Python 3.x √ºber deinen Package Manager"
    exit 1
fi

# Make script executable
chmod +x build_map.py

# Run Python build script
echo "üöÄ Starte Python Build Script..."
python3 build_map.py

if [ $? -eq 0 ]; then
    echo ""
    echo "üéâ Build erfolgreich!"
    echo "üìÅ Kompilierte Map: output/${mapName}.sd7"
else
    echo ""
    echo "‚ùå Build fehlgeschlagen!"
fi

echo ""
echo "‚ú® Fertig! Dr√ºcke Enter zum Beenden..."
read
`;
        }
        
        function generateRequirements() {
            return `# BAR Map Builder - Python Requirements
# Generiert von BAR Map Generator v1.0

# Basis-Bibliotheken (sollten mit Python Standard-Installation verf√ºgbar sein)
# urllib.request - f√ºr Downloads
# zipfile - f√ºr ZIP-Verarbeitung  
# subprocess - f√ºr externe Tools
# pathlib - f√ºr Dateipfade

# Keine zus√§tzlichen Abh√§ngigkeiten erforderlich!
# Dieses Script verwendet nur Python Standard-Bibliotheken.

# Falls du zus√§tzliche Features willst, k√∂nntest du installieren:
# Pillow>=9.0.0  # f√ºr erweiterte Bildverarbeitung
# requests>=2.25.0  # f√ºr bessere HTTP-Requests
`;
        }
        
        function generateDetailedReadme(mapName) {
            return `# BAR Map Builder - ${mapName}

Automatischer Map-Kompiler f√ºr Beyond All Reason (BAR)
Generiert von **BAR Map Generator v1.0**

## üìã Inhalt des Pakets

\`\`\`
${mapName}_complete_package/
‚îú‚îÄ‚îÄ üìÅ assets/              # Alle generierten Map-Assets
‚îÇ   ‚îú‚îÄ‚îÄ heightmap.png       # H√∂henkarte (16-bit)
‚îÇ   ‚îú‚îÄ‚îÄ metalmap.png        # Metallvorkommen
‚îÇ   ‚îú‚îÄ‚îÄ texture.png         # Oberfl√§chentextur
‚îÇ   ‚îú‚îÄ‚îÄ normalmap.png       # Normalmap f√ºr Details
‚îÇ   ‚îú‚îÄ‚îÄ specularmap.png     # Spiegelung/Glanz
‚îÇ   ‚îú‚îÄ‚îÄ minimap.png         # Minimap (1024x1024)
‚îÇ   ‚îú‚îÄ‚îÄ grassmap.png        # Grasdichte
‚îÇ   ‚îú‚îÄ‚îÄ typemap.png         # Gel√§ndetypen
‚îÇ   ‚îî‚îÄ‚îÄ splatmap.png        # Detail-Textur-Mapping
‚îú‚îÄ‚îÄ üìÑ mapinfo.lua          # Map-Konfiguration
‚îú‚îÄ‚îÄ üêç build_map.py         # Haupt-Build-Script (Python)
‚îú‚îÄ‚îÄ üîß build.bat            # Windows Build Script
‚îú‚îÄ‚îÄ üîß build.sh             # Linux/macOS Build Script
‚îî‚îÄ‚îÄ üìñ README.md            # Diese Datei
\`\`\`

## üöÄ Schnellstart

### Windows:
1. Doppelklick auf \`build.bat\`
2. Warten bis "Build erfolgreich!" erscheint
3. Fertige MAP findest du im \`output/\` Ordner

### Linux/macOS:
1. Terminal √∂ffnen in diesem Ordner
2. \`./build.sh\` ausf√ºhren (oder \`bash build.sh\`)
3. Fertige Map findest du im \`output/\` Ordner

### Manuell (alle Systeme):
\`\`\`bash
python3 build_map.py
\`\`\`

## üìã Voraussetzungen

- **Python 3.6+** (https://python.org)
- **Internet-Verbindung** (f√ºr Download der Spring Map Tools)
- **~500MB freier Speicher** (f√ºr Tools und tempor√§re Dateien)

Das Script l√§dt automatisch die ben√∂tigten Spring Map Tools herunter!

## üéØ Was passiert beim Build?

1. **Tool-Check**: Pr√ºft ob Spring Map Tools vorhanden sind
2. **Download**: L√§dt MapConv automatisch herunter falls n√∂tig
3. **Kompilierung**: Konvertiert alle PNG/BMP Assets in Spring-Format
4. **Packaging**: Erstellt die finale \`.sd7\` Map-Datei
5. **Installation**: Kopiert die Map automatisch in deinen BAR-Ordner

## üìÅ BAR Map-Ordner

Die fertige Map wird automatisch installiert in:

### Linux (Flatpak):
\`~/.var/app/info.beyondallreason.bar/data/maps/\`

### Linux (Native):
\`~/.spring/maps/\`

### Windows:
\`~/Documents/My Games/Spring/maps/\`

## üéÆ Map Details

- **Name**: ${mapName}
- **Gr√∂√üe**: ${mapConfig.size}x${mapConfig.size} (${mapConfig.size/64}x${mapConfig.size/64} Spring-Einheiten)
- **Terrain**: ${mapConfig.terrainType}
- **Spieler**: ${mapConfig.playerCount}
- **Metal-Spots**: ${mapConfig.metalSpots}
- **Geo-Spots**: ${mapConfig.geoSpots}

## üîß Troubleshooting

### "Python nicht gefunden"
- Installiere Python 3.x von https://python.org
- Stelle sicher, dass Python im PATH ist

### "MapConv Download fehlgeschlagen"
- Pr√ºfe deine Internet-Verbindung
- Versuche es sp√§ter nochmal
- Lade MapConv manuell von https://github.com/spring/spring/releases

### "Map nicht in BAR sichtbar"
- Starte BAR neu
- Pr√ºfe ob die .sd7 Datei im richtigen maps/ Ordner ist
- Pr√ºfe Dateiberechtigungen

### "Build fehlgeschlagen"
- Pr√ºfe ob alle Asset-Dateien im assets/ Ordner sind
- Stelle sicher, dass genug Speicherplatz frei ist
- F√ºhre das Script als Administrator/root aus (falls n√∂tig)

## üÜò Support

Falls du Probleme hast:

1. **Pr√ºfe die Konsolen-Ausgabe** auf Fehlermeldungen
2. **Stelle sicher**, dass alle Dateien extrahiert wurden
3. **Versuche das Python-Script direkt**: \`python3 build_map.py\`
4. **Manueller Build**: Verwende MapConv direkt mit den Assets

## üìù Technische Details

### Map-Format
- **SMF**: Surface Map File (H√∂hendaten + Metadaten)
- **SMT**: Surface Map Texture (komprimierte Texturen)
- **SD7**: Spring-ZIP-Archive mit allen Map-Dateien

### Asset-Aufl√∂sungen
- Heightmap: ${64 * (mapConfig.size/64) + 1}x${64 * (mapConfig.size/64) + 1} Pixel (1025x1025)
- Metalmap: ${32 * (mapConfig.size/64)}x${32 * (mapConfig.size/64)} Pixel (512x512)
- Grassmap: ${16 * (mapConfig.size/64)}x${16 * (mapConfig.size/64)} Pixel (256x256)
- Typemap: ${32 * (mapConfig.size/64)}x${32 * (mapConfig.size/64)} Pixel (512x512)
- Texture: ${512 * (mapConfig.size/64)}x${512 * (mapConfig.size/64)} Pixel (8192x8192)
- Minimap: 1024x1024 Pixel

## üéâ Viel Spa√ü mit deiner Map!

Erstellt mit ‚ù§Ô∏è vom **BAR Map Generator**
https://github.com/beyond-all-reason/bar-map-generator

---
*Dieses Paket wurde automatisch generiert am ${new Date().toLocaleDateString('de-DE')} um ${new Date().toLocaleTimeString('de-DE')}*
`;
        }
        
        function generateBARAssets() {
            const size = mapConfig.size;
            const mapUnits = size / 64; // BAR map units (e.g., 1024 = 16 units)
            
            console.log("Generating BAR assets for size:", size, "units:", mapUnits);
            
            return {
                // Core maps with correct BAR dimensions
                heightmap: generateBARHeightmap(),     // 16-bit PNG: (64 * mapUnits + 1)¬≤
                metalmap: generateBARMetalmap(),       // 8-bit BMP: (16 * mapUnits)¬≤
                texture: generateBARTexture(),         // 8-bit BMP: (512 * mapUnits)¬≤
                normalmap: generateBARNormalmap(),     // 8-bit PNG: same as texture
                specularmap: generateBARSpecularmap(), // 8-bit PNG: half of texture
                minimap: generateBARMinimap(),         // 8-bit PNG: 1024x1024
                grassmap: generateBARGrassmap(),       // 8-bit BMP: (16 * mapUnits)¬≤
                typemap: generateBARTypemap(),         // 8-bit BMP: (16 * mapUnits)¬≤
                splatmap: generateBARSplatmap(),       // RGBA PNG: 2048x(2048*aspect)
                
                // Configuration
                mapinfo: generateBARMapInfo(),
                maphelper: generateBARMapHelper(),
                
                // Asset lists for folders
                features: [],
                mapconfig: {},
                objects3d: [],
                unittextures: []
            };
        }
        
        function generateBARHeightmap() {
            const size = mapConfig.size;
            const mapUnits = size / 64;
            const heightmapSize = 64 * mapUnits + 1;
            
            const canvas = document.createElement('canvas');
            canvas.width = heightmapSize;
            canvas.height = heightmapSize;
            const ctx = canvas.getContext('2d');
            
            const imageData = ctx.createImageData(heightmapSize, heightmapSize);
            const scale = size / heightmapSize;
            
            for (let y = 0; y < heightmapSize; y++) {
                for (let x = 0; x < heightmapSize; x++) {
                    const sourceX = Math.floor(x * scale);
                    const sourceY = Math.floor(y * scale);
                    const height = heightmapData[sourceY * size + sourceX];
                    const index = (y * heightmapSize + x) * 4;
                    
                    // For BMP format, use simple 8-bit grayscale (PyMapConv can handle this)
                    imageData.data[index] = height;       // R - height value
                    imageData.data[index + 1] = height;   // G - height value (grayscale)
                    imageData.data[index + 2] = height;   // B - height value (grayscale)
                    imageData.data[index + 3] = 255;      // A - full alpha
                }
            }
            
            ctx.putImageData(imageData, 0, 0);
            return canvas;
        }
        
        function generateBARMetalmap() {
            const size = mapConfig.size;
            const mapUnits = size / 64;
            // PyMapConv expects 32 * mapUnits for metalmap (512x512 for 16x16 map)
            const metalmapSize = 32 * mapUnits; // Corrected size: 512x512 for 1024x1024 map
            
            const canvas = document.createElement('canvas');
            canvas.width = metalmapSize;
            canvas.height = metalmapSize;
            const ctx = canvas.getContext('2d');
            
            // Clear to black (no metal)
            ctx.fillStyle = '#000000';
            ctx.fillRect(0, 0, metalmapSize, metalmapSize);
            
            // Draw metal spots as pure red pixels
            const scale = metalmapSize / size;
            ctx.fillStyle = '#FF0000'; // Full red = max metal
            
            resourceData.metalSpots.forEach(spot => {
                const x = Math.floor(spot.x * scale);
                const y = Math.floor(spot.y * scale);
                const metalRadius = 2; // 4px diameter as per BAR documentation
                
                ctx.beginPath();
                ctx.arc(x, y, metalRadius, 0, 2 * Math.PI);
                ctx.fill();
            });
            
            return canvas;
        }
        
        function generateBARTexture() {
            const size = mapConfig.size;
            const mapUnits = size / 64;
            const textureSize = 512 * mapUnits;
            
            const canvas = document.createElement('canvas');
            canvas.width = textureSize;
            canvas.height = textureSize;
            const ctx = canvas.getContext('2d');
            
            const imageData = ctx.createImageData(textureSize, textureSize);
            const scale = size / textureSize;
            
            for (let y = 0; y < textureSize; y++) {
                for (let x = 0; x < textureSize; x++) {
                    const sourceX = Math.floor(x * scale);
                    const sourceY = Math.floor(y * scale);
                    const sourceIndex = (sourceY * size + sourceX) * 4;
                    const index = (y * textureSize + x) * 4;
                    
                    imageData.data[index] = textureData[sourceIndex];         // R
                    imageData.data[index + 1] = textureData[sourceIndex + 1]; // G
                    imageData.data[index + 2] = textureData[sourceIndex + 2]; // B
                    imageData.data[index + 3] = 255;                          // A - solid, no transparency
                }
            }
            
            ctx.putImageData(imageData, 0, 0);
            return canvas;
        }
        
        function generateBARNormalmap() {
            const size = mapConfig.size;
            const mapUnits = size / 64;
            const normalmapSize = 512 * mapUnits;
            
            const canvas = document.createElement('canvas');
            canvas.width = normalmapSize;
            canvas.height = normalmapSize;
            const ctx = canvas.getContext('2d');
            
            const imageData = ctx.createImageData(normalmapSize, normalmapSize);
            
            // Generate simple normalmap from heightmap
            for (let y = 0; y < normalmapSize; y++) {
                for (let x = 0; x < normalmapSize; x++) {
                    const heightScale = size / normalmapSize;
                    const hx = Math.floor(x * heightScale);
                    const hy = Math.floor(y * heightScale);
                    
                    // Sample neighboring heights for normal calculation
                    const h0 = getHeightAt(hx, hy);
                    const h1 = getHeightAt(hx + 1, hy);
                    const h2 = getHeightAt(hx, hy + 1);
                    
                    // Calculate normal
                    const dx = (h1 - h0) / 255;
                    const dy = (h2 - h0) / 255;
                    
                    const nx = -dx;
                    const ny = -dy;
                    const nz = 1;
                    
                    // Normalize
                    const length = Math.sqrt(nx * nx + ny * ny + nz * nz);
                    const normalX = (nx / length + 1) * 127.5;
                    const normalY = (ny / length + 1) * 127.5;
                    const normalZ = (nz / length + 1) * 127.5;
                    
                    const index = (y * normalmapSize + x) * 4;
                    imageData.data[index] = normalX;     // R
                    imageData.data[index + 1] = normalY; // G
                    imageData.data[index + 2] = normalZ; // B
                    imageData.data[index + 3] = 255;     // A
                }
            }
            
            ctx.putImageData(imageData, 0, 0);
            return canvas;
        }
        
        function getHeightAt(x, y) {
            const size = mapConfig.size;
            x = Math.max(0, Math.min(size - 1, x));
            y = Math.max(0, Math.min(size - 1, y));
            return heightmapData[y * size + x];
        }
        
        function generateBARSpecularmap() {
            const size = mapConfig.size;
            const mapUnits = size / 64;
            const specularSize = 256 * mapUnits; // Half resolution
            
            const canvas = document.createElement('canvas');
            canvas.width = specularSize;
            canvas.height = specularSize;
            const ctx = canvas.getContext('2d');
            
            const imageData = ctx.createImageData(specularSize, specularSize);
            const scale = size / specularSize;
            
            for (let y = 0; y < specularSize; y++) {
                for (let x = 0; x < specularSize; x++) {
                    const sourceX = Math.floor(x * scale);
                    const sourceY = Math.floor(y * scale);
                    const height = heightmapData[sourceY * size + sourceX];
                    const index = (y * specularSize + x) * 4;
                    
                    // Generate specular based on height and material type
                    let specular = 64; // Base specular
                    if (height < mapConfig.waterLevel) {
                        specular = 200; // Water is reflective
                    } else if (height > mapConfig.waterLevel + 100) {
                        specular = 128; // Rock is somewhat reflective
                    }
                    
                    imageData.data[index] = specular;     // R
                    imageData.data[index + 1] = specular; // G
                    imageData.data[index + 2] = specular; // B
                    imageData.data[index + 3] = 255;      // A
                }
            }
            
            ctx.putImageData(imageData, 0, 0);
            return canvas;
        }
        
        function generateBARMinimap() {
            const canvas = document.createElement('canvas');
            canvas.width = 1024;
            canvas.height = 1024;
            const ctx = canvas.getContext('2d');
            
            const imageData = ctx.createImageData(1024, 1024);
            const scale = mapConfig.size / 1024;
            
            for (let y = 0; y < 1024; y++) {
                for (let x = 0; x < 1024; x++) {
                    const sourceX = Math.floor(x * scale);
                    const sourceY = Math.floor(y * scale);
                    const sourceIndex = (sourceY * mapConfig.size + sourceX) * 4;
                    const index = (y * 1024 + x) * 4;
                    
                    imageData.data[index] = textureData[sourceIndex];         // R
                    imageData.data[index + 1] = textureData[sourceIndex + 1]; // G
                    imageData.data[index + 2] = textureData[sourceIndex + 2]; // B
                    imageData.data[index + 3] = 255;                          // A
                }
            }
            
            ctx.putImageData(imageData, 0, 0);
            return canvas;
        }
        
        function generateBARGrassmap() {
            const size = mapConfig.size;
            const mapUnits = size / 64;
            // PyMapConv expects 16 * mapUnits for grassmap (256x256 for 16x16 map)
            const grassSize = 16 * mapUnits; // Corrected size: 256x256 for 1024x1024 map
            
            const canvas = document.createElement('canvas');
            canvas.width = grassSize;
            canvas.height = grassSize;
            const ctx = canvas.getContext('2d');
            
            const imageData = ctx.createImageData(grassSize, grassSize);
            const scale = size / grassSize;
            
            for (let y = 0; y < grassSize; y++) {
                for (let x = 0; x < grassSize; x++) {
                    const sourceX = Math.floor(x * scale);
                    const sourceY = Math.floor(y * scale);
                    const height = heightmapData[sourceY * size + sourceX];
                    const index = (y * grassSize + x) * 4;
                    
                    // Grass density based on height (grass grows on land, not water)
                    let grassDensity = 0;
                    if (height > mapConfig.waterLevel + 5 && height < mapConfig.waterLevel + 100) {
                        grassDensity = 128 + Math.random() * 127; // Medium to high grass on suitable terrain
                    }
                    
                    imageData.data[index] = grassDensity;     // R
                    imageData.data[index + 1] = grassDensity; // G
                    imageData.data[index + 2] = grassDensity; // B
                    imageData.data[index + 3] = 255;          // A (will be removed in BMP conversion)
                }
            }
            
            ctx.putImageData(imageData, 0, 0);
            return canvas;
        }
        
        function generateBARTypemap() {
            const size = mapConfig.size;
            const mapUnits = size / 64;
            // PyMapConv expects 32 * mapUnits for typemap (512x512 for 16x16 map)  
            const typeSize = 32 * mapUnits; // Corrected size: 512x512 for 1024x1024 map
            
            const canvas = document.createElement('canvas');
            canvas.width = typeSize;
            canvas.height = typeSize;
            const ctx = canvas.getContext('2d');
            
            const imageData = ctx.createImageData(typeSize, typeSize);
            const scale = size / typeSize;
            
            for (let y = 0; y < typeSize; y++) {
                for (let x = 0; x < typeSize; x++) {
                    const sourceX = Math.floor(x * scale);
                    const sourceY = Math.floor(y * scale);
                    const height = heightmapData[sourceY * size + sourceX];
                    const index = (y * typeSize + x) * 4;
                    
                    // Type based on height (0=water, 85=land, 170=rock, 255=snow)
                    let type = 0; // Water
                    if (height > mapConfig.waterLevel) {
                        if (height < mapConfig.waterLevel + 80) {
                            type = 85; // Normal land
                        } else if (height < mapConfig.waterLevel + 150) {
                            type = 170; // Rock/hills
                        } else {
                            type = 255; // Snow/peaks
                        }
                    }
                    
                    imageData.data[index] = type;     // R
                    imageData.data[index + 1] = type; // G
                    imageData.data[index + 2] = type; // B
                    imageData.data[index + 3] = 255;  // A
                }
            }
            
            ctx.putImageData(imageData, 0, 0);
            return canvas;
        }
        
        function generateBARSplatmap() {
            const size = Math.max(2048, mapConfig.size / 2); // At least 2048px as per documentation
            const aspectRatio = 1; // Square map
            
            const canvas = document.createElement('canvas');
            canvas.width = size;
            canvas.height = size * aspectRatio;
            const ctx = canvas.getContext('2d');
            
            // Simple splatmap - can be expanded for more detail textures
            const imageData = ctx.createImageData(canvas.width, canvas.height);
            
            for (let y = 0; y < canvas.height; y++) {
                for (let x = 0; x < canvas.width; x++) {
                    const index = (y * canvas.width + x) * 4;
                    
                    // RGBA channels for 4 different detail textures
                    imageData.data[index] = 255;     // R - Channel 1: Base terrain
                    imageData.data[index + 1] = 0;   // G - Channel 2: Rock/cliffs
                    imageData.data[index + 2] = 0;   // B - Channel 3: Sand/beach
                    imageData.data[index + 3] = 0;   // A - Channel 4: Snow/ice
                }
            }
            
            ctx.putImageData(imageData, 0, 0);
            return canvas;
        }
        
        // INDIVIDUAL DOWNLOAD FUNCTIONS
        function downloadHeightmap() {
            if (!heightmapData) {
                alert('Please generate a map first!');
                return;
            }
            
            const canvas = generateBARHeightmap();
            canvas.toBlob(blob => {
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `heightmap_${mapConfig.size}x${mapConfig.size}.png`;
                a.click();
                URL.revokeObjectURL(url);
            });
        }
        
        function downloadMetalmap() {
            if (!heightmapData) {
                alert('Please generate a map first!');
                return;
            }
            
            const canvas = generateBARMetalmap();
            canvas.toBlob(blob => {
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `metalmap_${mapConfig.size}x${mapConfig.size}.bmp`;
                a.click();
                URL.revokeObjectURL(url);
            });
        }
        
        function downloadNormalmap() {
            if (!heightmapData) {
                alert('Please generate a map first!');
                return;
            }
            
            const canvas = generateBARNormalmap();
            canvas.toBlob(blob => {
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `normalmap_${mapConfig.size}x${mapConfig.size}.png`;
                a.click();
                URL.revokeObjectURL(url);
            });
        }
        
        function downloadSpecularmap() {
            if (!heightmapData) {
                alert('Please generate a map first!');
                return;
            }
            
            const canvas = generateBARSpecularmap();
            canvas.toBlob(blob => {
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `specularmap_${mapConfig.size}x${mapConfig.size}.png`;
                a.click();
                URL.revokeObjectURL(url);
            });
        }
        
        function downloadMinimap() {
            if (!heightmapData) {
                alert('Please generate a map first!');
                return;
            }
            
            const canvas = generateBARMinimap();
            canvas.toBlob(blob => {
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `minimap_1024x1024.png`;
                a.click();
                URL.revokeObjectURL(url);
            });
        }
        
        function downloadTexture() {
            if (!textureData) {
                alert('Please generate a map first!');
                return;
            }
            
            const canvas = document.createElement('canvas');
            const size = mapConfig.size;
            canvas.width = size;
            canvas.height = size;
            const ctx = canvas.getContext('2d');
            
            const imageData = ctx.createImageData(size, size);
            
            for (let i = 0; i < textureData.length; i++) {
                imageData.data[i] = textureData[i];
            }
            
            ctx.putImageData(imageData, 0, 0);
            
            canvas.toBlob(blob => {
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `texture_${size}x${size}.png`;
                a.click();
                URL.revokeObjectURL(url);
            });
        }
        
        // ZIP CREATION FOR COMPLETE MAP PACKAGE
        async function createCompleteMapPackage(assets, buildScripts, mapName) {
            if (typeof JSZip === 'undefined') {
                throw new Error('JSZip library not available. Please reload the page.');
            }
            
            const zip = new JSZip();
            
            console.log("Creating complete BAR map package...");
            
            // Create directory structure
            const assetsFolder = zip.folder("assets");
            
            // Add build scripts (root level)
            zip.file("build_map.py", buildScripts.python);
            zip.file("build.bat", buildScripts.batch);
            zip.file("build.sh", buildScripts.bash);
            zip.file("requirements.txt", buildScripts.requirements);
            zip.file("README.md", buildScripts.readme);
            
            // Add mapinfo.lua (root level for MapConv)
            zip.file("mapinfo.lua", assets.mapinfo);
            
            // Convert canvases to blobs with correct formats for PyMapConv
            const heightmapBlob = await canvasToBlob(assets.heightmap, 'image/png');  // Keep PNG for heightmap
            const metalmapBlob = await canvasToBlob(assets.metalmap, 'image/bmp');
            const textureBlob = await canvasToBlob(assets.texture, 'image/bmp');      // BMP without alpha
            const normalmapBlob = await canvasToBlob(assets.normalmap, 'image/png');
            const specularmapBlob = await canvasToBlob(assets.specularmap, 'image/png');
            const minimapBlob = await canvasToBlob(assets.minimap, 'image/png');
            const grassmapBlob = await canvasToBlob(assets.grassmap, 'image/bmp');
            const typemapBlob = await canvasToBlob(assets.typemap, 'image/bmp');
            const splatmapBlob = await canvasToBlob(assets.splatmap, 'image/png');
            
            // Add all asset files to assets folder
            // Add all asset files to assets folder with correct formats for PyMapConv
            assetsFolder.file("heightmap.bmp", heightmapBlob);  // BMP for heightmap (8-bit is acceptable)
            assetsFolder.file("metalmap.bmp", metalmapBlob);
            assetsFolder.file("texture.bmp", textureBlob);      // BMP without alpha channel
            assetsFolder.file("normalmap.png", normalmapBlob);
            assetsFolder.file("specularmap.png", specularmapBlob);
            assetsFolder.file("minimap.png", minimapBlob);
            assetsFolder.file("grassmap.bmp", grassmapBlob);
            assetsFolder.file("typemap.bmp", typemapBlob);
            assetsFolder.file("splatmap.png", splatmapBlob);
            
            // Add package metadata
            zip.file("VERSION", "1.0\nGenerated by BAR Map Generator");
            zip.file("INSTALL.txt", generateInstallInstructions(mapName));
            
            // Generate the ZIP file
            console.log("Generating complete package ZIP...");
            const zipBlob = await zip.generateAsync({
                type: "blob",
                compression: "DEFLATE",
                compressionOptions: {
                    level: 6
                }
            });
            
            console.log("Complete package generated successfully, size:", zipBlob.size, "bytes");
            return zipBlob;
        }
        
        function generateInstallInstructions(mapName) {
            return `BAR Map Builder - Installationsanleitung
==========================================

üéØ SCHNELLSTART:

Windows:
  Doppelklick auf build.bat

Linux/macOS:
  Terminal √∂ffnen ‚Üí ./build.sh ausf√ºhren

üìã VORAUSSETZUNGEN:
- Python 3.6+ (https://python.org)
- Internet-Verbindung
- ~500MB freier Speicher

üîß WAS PASSIERT:
1. Spring Map Tools werden automatisch heruntergeladen
2. Alle Assets werden in BAR-Format kompiliert
3. Fertige .sd7 Map wird in deinen BAR-Ordner kopiert

üéÆ DANN:
- BAR starten
- "${mapName}" in der Map-Liste finden
- Spielen!

üìÅ PAKET-INHALT:
- assets/: Alle Map-Grafiken (PNG/BMP)
- build_map.py: Haupt-Kompiler (Python)
- build.bat: Windows-Script
- build.sh: Linux/macOS-Script  
- mapinfo.lua: Map-Konfiguration
- README.md: Detaillierte Anleitung

üÜò PROBLEME?
Siehe README.md f√ºr Troubleshooting

Erstellt: ${new Date().toLocaleDateString('de-DE')}
Generator: BAR Map Generator v1.0
`;
        }
        
        function canvasToBlob(canvas, type = 'image/png') {
            return new Promise(resolve => {
                // For BMP files, we need to ensure RGB format (no alpha)
                if (type === 'image/bmp') {
                    // Create a new canvas with RGB-only context
                    const rgbCanvas = document.createElement('canvas');
                    rgbCanvas.width = canvas.width;
                    rgbCanvas.height = canvas.height;
                    const rgbCtx = rgbCanvas.getContext('2d', { alpha: false });
                    
                    // Fill with black background (for heightmaps/metal) or white (for textures)
                    rgbCtx.fillStyle = 'black';
                    rgbCtx.fillRect(0, 0, rgbCanvas.width, rgbCanvas.height);
                    
                    // Set composite operation to overwrite alpha
                    rgbCtx.globalCompositeOperation = 'source-over';
                    
                    // Draw original canvas on top
                    rgbCtx.drawImage(canvas, 0, 0);
                    
                    // Force RGB by creating image data and removing alpha
                    const imageData = rgbCtx.getImageData(0, 0, rgbCanvas.width, rgbCanvas.height);
                    for (let i = 3; i < imageData.data.length; i += 4) {
                        imageData.data[i] = 255; // Set alpha to 255 (opaque)
                    }
                    rgbCtx.putImageData(imageData, 0, 0);
                    
                    // Convert to blob as PNG (browsers don't support BMP creation well)
                    rgbCanvas.toBlob(resolve, 'image/png');
                } else {
                    canvas.toBlob(resolve, type);
                }
            });
        }
        
        function generateReadme(mapName) {
            return `BAR Map: ${mapName}
=========================

Diese Map wurde automatisch mit dem BAR Map Generator erstellt.

Inhalt der SD7-Datei:
- mapinfo.lua: Hauptkonfiguration der Map
- maphelper/maphelper.lua: Hilfsfunktionen f√ºr die Map
- maps/: Alle Bild-Assets der Map
  * ${mapName}.smf.png: H√∂henkarte (Heightmap)
  * ${mapName}_metal.png: Metallvorkommen
  * ${mapName}_texture.png: Oberfl√§chentextur
  * ${mapName}_normal.png: Normalmap f√ºr Details
  * ${mapName}_specular.png: Spiegelung/Glanz
  * ${mapName}_minimap.png: Minimap
  * ${mapName}_grass.png: Grasdichte
  * ${mapName}_type.png: Gel√§ndetypen
  * ${mapName}_splat.png: Detail-Textur-Mapping

Installation:
1. Diese .sd7 Datei in den BAR maps Ordner kopieren
2. BAR neustarten
3. Map im Spiel ausw√§hlen

Weitere Informationen:
- Generator Version: 1.0
- Erstellt: ${new Date().toLocaleDateString('de-DE')}
- Map-Gr√∂√üe: ${mapConfig.size}x${mapConfig.size}
- Terrain-Typ: ${mapConfig.terrainType}
- Spieler: ${mapConfig.playerCount}

BAR Map Generator
https://github.com/beyond-all-reason/bar-map-generator
`;
        }
        
        function generateBARMapInfo() {
            const config = mapConfig;
            const mapUnits = config.size / 64;
            
            return `-- Beyond All Reason Map Configuration
-- Generated by BAR Map Generator
-- Map Size: ${config.size}x${config.size} (${mapUnits}x${mapUnits} units)
-- Terrain Type: ${config.terrainType}
-- Players: ${config.playerCount}

return {
    -- Basic map info
    name = "Generated ${config.terrainType} Map ${config.size}x${config.size}",
    shortname = "gen_${config.terrainType}_${config.size}",
    description = "Procedurally generated ${config.terrainType} map for ${config.playerCount} players",
    author = "BAR Map Generator",
    version = "1.0",
    
    -- Map dimensions (in Spring units)
    mapx = ${config.size * 8}, -- Spring map units (size * 8)
    mapy = ${config.size * 8},
    
    -- Gameplay settings
    maxplayers = ${config.playerCount},
    gravity = 130,
    tidalstrength = 20,
    maxmetal = ${(config.metalSpots * config.metalStrength).toFixed(1)},
    extractorradius = 64,
    
    -- Water settings
    waterlevel = ${(config.waterLevel / 255 * config.heightVariation).toFixed(1)},
    waterdamage = 5,
    
    -- Visual settings
    lighting = {
        specularexponent = 100,
        groundshadowdensity = 0.8,
        groundreflectance = 0.1,
    },
    
    -- Atmosphere
    atmosphere = {
        minheight = -500,
        maxheight = 10000,
        thickness = 400,
        color = {0.5, 0.7, 1.0},
    },
    
    -- Start positions
    teams = {`;
            
            config.startPositions.forEach((pos, index) => {
                const springX = pos.x * 8; // Convert to Spring coordinates
                const springZ = pos.y * 8;
                return `
        [${index}] = {
            startposx = ${springX},
            startposz = ${springZ},
        },`;
            }).join('');
            
            const mapInfo = `
    },
    
    -- Metal spots
    metal = {`;
            
            resourceData.metalSpots.forEach((spot, index) => {
                const springX = spot.x * 8;
                const springZ = spot.y * 8;
                return `
        [${index}] = {
            x = ${springX},
            z = ${springZ},
            metal = ${spot.value.toFixed(1)},
        },`;
            }).join('');
            
            const geoInfo = `
    },
    
    -- Geothermal spots  
    geothermal = {`;
            
            resourceData.geoSpots.forEach((spot, index) => {
                const springX = spot.x * 8;
                const springZ = spot.y * 8;
                return `
        [${index}] = {
            x = ${springX},
            z = ${springZ},
            energy = ${spot.value.toFixed(0)},
        },`;
            }).join('');
            
            const endInfo = `
    },
    
    -- Terrain types
    terraintypes = {
        [0] = {
            name = "Water",
            hardness = 0.0,
            receiveTrackstype = 0,
            movespeed = {
                tank = 0.0,
                kbot = 0.0,
                hover = 1.0,
                ship = 1.0,
            },
        },
        [1] = {
            name = "Land",
            hardness = 1.0,
            receiveTrackstype = 1,
            movespeed = {
                tank = 1.0,
                kbot = 1.0,
                hover = 1.0,
                ship = 0.0,
            },
        },
        [2] = {
            name = "Rock",
            hardness = 1.0,
            receiveTrackstype = 1,
            movespeed = {
                tank = 0.8,
                kbot = 0.9,
                hover = 1.0,
                ship = 0.0,
            },
        },
        [3] = {
            name = "Snow",
            hardness = 0.8,
            receiveTrackstype = 1,
            movespeed = {
                tank = 0.7,
                kbot = 0.8,
                hover = 1.0,
                ship = 0.0,
            },
        },
    },
    
    -- Custom properties
    custom = {
        terrain_type = "${config.terrainType}",
        noise_strength = ${config.noiseStrength},
        height_variation = ${config.heightVariation},
        generated = true,
        generator_version = "1.0",
    },
    
    -- Splat texture detail
    splatdetailnormalmap = "maps/${config.terrainType}_detail_normal.png",
    splatdetaildiffusetex = "maps/${config.terrainType}_detail_diffuse.png",
    
    -- Map features can be added here
    featureplacer = {},
}`;
            
            return mapInfo + geoInfo + endInfo;
        }
        
        function generateBARMapHelper() {
            return `-- Map Helper for BAR
-- Generated by BAR Map Generator

if not Script then
    Script = {}
end

local mapName = Game.mapName or "generated_map"

-- Helper functions for map initialization
function Script.MapPostLoad()
    -- Map-specific initialization can go here
    Spring.Echo("Map loaded: " .. mapName)
end

return {}`;
        }
        
        function downloadConfig() {
            if (!mapConfig) {
                alert('Please generate a map first!');
                return;
            }
            
            const luaConfig = generateBARMapInfo();
            const blob = new Blob([luaConfig], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `mapinfo_${mapConfig.size}x${mapConfig.size}.lua`;
            a.click();
            URL.revokeObjectURL(url);
        }
        
        // Initialize displays on page load
        window.addEventListener('load', function() {
            updateValueDisplays();
            initWebGL();
            initCameraControls();
        });
    </script>
</body>
</html>
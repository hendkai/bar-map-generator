<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Round-trip Verification Runner</title>
    <style>
        body {
            font-family: 'Courier New', monospace;
            max-width: 900px;
            margin: 0 auto;
            padding: 20px;
            background: #1e1e1e;
            color: #d4d4d4;
        }
        h1 {
            color: #4ec9b0;
            border-bottom: 2px solid #4ec9b0;
            padding-bottom: 10px;
        }
        .test-section {
            background: #252526;
            padding: 15px;
            margin: 10px 0;
            border-radius: 4px;
            border-left: 4px solid #007acc;
        }
        .success {
            color: #4ec9b0;
            font-weight: bold;
        }
        .failure {
            color: #f48771;
            font-weight: bold;
        }
        .info {
            color: #569cd6;
        }
        button {
            background: #007acc;
            color: white;
            border: none;
            padding: 12px 24px;
            margin: 10px 5px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            font-family: 'Courier New', monospace;
        }
        button:hover {
            background: #0098ff;
        }
        button:disabled {
            background: #3d3d3d;
            cursor: not-allowed;
        }
        #output {
            background: #1e1e1e;
            border: 1px solid #3d3d3d;
            padding: 15px;
            margin: 20px 0;
            border-radius: 4px;
            max-height: 500px;
            overflow-y: auto;
            white-space: pre-wrap;
            font-size: 13px;
        }
        .summary {
            background: #252526;
            padding: 20px;
            margin: 20px 0;
            border-radius: 4px;
            border: 2px solid #007acc;
        }
        .summary h2 {
            margin-top: 0;
            color: #4ec9b0;
        }
        .progress-bar {
            width: 100%;
            height: 30px;
            background: #3d3d3d;
            border-radius: 4px;
            margin: 10px 0;
            overflow: hidden;
        }
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #007acc, #4ec9b0);
            transition: width 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            color: white;
        }
    </style>
</head>
<body>
    <h1>ðŸ”ƒ Round-trip Export/Import Verification Runner</h1>

    <div class="test-section">
        <h2>Instructions</h2>
        <p>This tool automatically tests the round-trip export/import workflow by simulating the functions from bar_map_generator.html.</p>
        <p><strong>Click the button below to run all tests:</strong></p>
        <button onclick="runAllTests()" id="runButton">â–¶ Run All Verification Tests</button>
        <button onclick="clearOutput()" id="clearButton">Clear Output</button>
    </div>

    <div class="summary" id="summary" style="display: none;">
        <h2>Test Results Summary</h2>
        <div class="progress-bar">
            <div class="progress-fill" id="progressFill">0%</div>
        </div>
        <p><strong>Total Tests:</strong> <span id="totalTests">0</span></p>
        <p><strong>Passed:</strong> <span id="passedTests" class="success">0</span></p>
        <p><strong>Failed:</strong> <span id="failedTests" class="failure">0</span></p>
        <p><strong>Pass Rate:</strong> <span id="passRate">0%</span></p>
        <p><strong>Overall Status:</strong> <span id="overallStatus">Pending</span></p>
    </div>

    <div id="output">Ready to run tests...</div>

    <script>
        // Simulate the export/import functions from bar_map_generator.html
        function simulateExportConfigJSON(mapConfig, creatorName, mapDescription) {
            const exportData = {
                version: '1.0',
                timestamp: new Date().toISOString(),
                metadata: {
                    creator: creatorName || 'Anonymous',
                    description: mapDescription || 'No description'
                },
                config: { ...mapConfig }
            };

            return JSON.stringify(exportData, null, 2);
        }

        function simulateImportConfigJSON(jsonString) {
            const importData = JSON.parse(jsonString);

            if (!importData.version || !importData.config) {
                throw new Error('Invalid configuration file format. Missing required fields.');
            }

            return importData;
        }

        function simulateExportConfigText(mapConfig, creatorName, mapDescription) {
            const exportData = {
                version: '1.0',
                timestamp: new Date().toISOString(),
                metadata: {
                    creator: creatorName || 'Anonymous',
                    description: mapDescription || 'No description'
                },
                config: { ...mapConfig }
            };

            const jsonString = JSON.stringify(exportData);
            return btoa(jsonString);
        }

        function simulateImportConfigText(base64String) {
            const jsonString = atob(base64String);
            const importData = JSON.parse(jsonString);

            if (!importData.version || !importData.config) {
                throw new Error('Invalid configuration format. Missing required fields.');
            }

            return importData;
        }

        function compareConfigs(original, imported) {
            const mismatches = [];

            Object.keys(original).forEach(key => {
                if (original[key] !== imported[key]) {
                    mismatches.push({
                        field: key,
                        original: original[key],
                        imported: imported[key]
                    });
                }
            });

            return mismatches;
        }

        function log(message, type = 'info') {
            const output = document.getElementById('output');
            const timestamp = new Date().toLocaleTimeString();

            let color = '#d4d4d4';
            if (type === 'success') color = '#4ec9b0';
            if (type === 'error') color = '#f48771';
            if (type === 'header') color = '#569cd6';
            if (type === 'test') color = '#dcdcaa';

            const line = document.createElement('div');
            line.style.color = color;
            line.textContent = `[${timestamp}] ${message}`;
            output.appendChild(line);

            // Auto-scroll to bottom
            output.scrollTop = output.scrollHeight;
        }

        function clearOutput() {
            document.getElementById('output').innerHTML = 'Ready to run tests...';
            document.getElementById('summary').style.display = 'none';
        }

        const testCases = [
            {
                name: 'Basic Configuration',
                config: {
                    size: 1024,
                    terrainType: 'continental',
                    playerCount: 4,
                    noiseStrength: 0.5,
                    heightVariation: 0.6,
                    waterLevel: 0.3,
                    metalSpots: 50,
                    metalStrength: 0.7,
                    geoSpots: 10,
                    startPositions: []
                },
                metadata: {
                    creator: 'Test User',
                    description: 'Test configuration for round-trip verification'
                }
            },
            {
                name: 'Extreme Values',
                config: {
                    size: 2048,
                    terrainType: 'hills',
                    playerCount: 8,
                    noiseStrength: 1.0,
                    heightVariation: 1.0,
                    waterLevel: 1.0,
                    metalSpots: 100,
                    metalStrength: 1.0,
                    geoSpots: 50,
                    startPositions: []
                },
                metadata: {
                    creator: 'Extreme Tester',
                    description: 'Testing maximum values'
                }
            },
            {
                name: 'Minimum Values',
                config: {
                    size: 512,
                    terrainType: 'flat',
                    playerCount: 2,
                    noiseStrength: 0.0,
                    heightVariation: 0.0,
                    waterLevel: 0.0,
                    metalSpots: 0,
                    metalStrength: 0.0,
                    geoSpots: 0,
                    startPositions: []
                },
                metadata: {
                    creator: 'Min Tester',
                    description: 'Testing minimum values'
                }
            },
            {
                name: 'All Terrain Types',
                config: {
                    size: 1024,
                    terrainType: 'canyon',
                    playerCount: 6,
                    noiseStrength: 0.75,
                    heightVariation: 0.8,
                    waterLevel: 0.4,
                    metalSpots: 75,
                    metalStrength: 0.9,
                    geoSpots: 25,
                    startPositions: []
                },
                metadata: {
                    creator: 'Terrain Tester',
                    description: 'Testing canyon terrain'
                }
            },
            {
                name: 'Special Characters',
                config: {
                    size: 1024,
                    terrainType: 'islands',
                    playerCount: 4,
                    noiseStrength: 0.5,
                    heightVariation: 0.6,
                    waterLevel: 0.3,
                    metalSpots: 50,
                    metalStrength: 0.7,
                    geoSpots: 10,
                    startPositions: []
                },
                metadata: {
                    creator: 'Test "Quotes" & <Symbols>',
                    description: 'Config with Ã©mojis ðŸ˜ŠðŸŽ® and unicode: ä¸­æ–‡ æ¼¢å­—'
                }
            },
            {
                name: 'Empty Metadata',
                config: {
                    size: 1024,
                    terrainType: 'continental',
                    playerCount: 4,
                    noiseStrength: 0.5,
                    heightVariation: 0.6,
                    waterLevel: 0.3,
                    metalSpots: 50,
                    metalStrength: 0.7,
                    geoSpots: 10,
                    startPositions: []
                },
                metadata: {
                    creator: '',
                    description: ''
                }
            }
        ];

        const terrainTypes = ['continental', 'islands', 'canyon', 'hills', 'flat'];
        const mapSizes = [512, 1024, 2048];

        async function runAllTests() {
            document.getElementById('runButton').disabled = true;
            clearOutput();

            log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', 'header');
            log('ROUND-TRIP EXPORT/IMPORT VERIFICATION SUITE', 'header');
            log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', 'header');

            let totalTests = 0;
            let passedTests = 0;
            let failedTests = 0;

            // Delay utility
            const delay = ms => new Promise(resolve => setTimeout(resolve, ms));

            // Test JSON round-trip
            log('\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€', 'header');
            log('JSON ROUND-TRIP TESTS', 'header');
            log('â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€', 'header');

            for (let i = 0; i < testCases.length; i++) {
                const testCase = testCases[i];
                totalTests++;

                log(`\n[JSON Test ${i + 1}/${testCases.length}] ${testCase.name}`, 'test');

                try {
                    // Export
                    const jsonString = simulateExportConfigJSON(
                        testCase.config,
                        testCase.metadata.creator,
                        testCase.metadata.description
                    );

                    // Import
                    const imported = simulateImportConfigJSON(jsonString);

                    // Compare
                    const configMismatches = compareConfigs(testCase.config, imported.config);
                    const metadataMismatches = compareConfigs(testCase.metadata, imported.metadata);
                    const allMismatches = [...configMismatches, ...metadataMismatches];

                    if (allMismatches.length === 0) {
                        log(`  âœ“ PASSED: All values preserved`, 'success');
                        passedTests++;
                    } else {
                        log(`  âœ— FAILED: Mismatches detected:`, 'error');
                        allMismatches.forEach(mismatch => {
                            log(`    - ${mismatch.field}: "${mismatch.original}" â†’ "${mismatch.imported}"`, 'error');
                        });
                        failedTests++;
                    }

                } catch (error) {
                    log(`  âœ— FAILED: Exception: ${error.message}`, 'error');
                    failedTests++;
                }

                updateSummary(totalTests, passedTests, failedTests);
                await delay(100);
            }

            // Test Text round-trip
            log('\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€', 'header');
            log('TEXT ROUND-TRIP TESTS', 'header');
            log('â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€', 'header');

            for (let i = 0; i < testCases.length; i++) {
                const testCase = testCases[i];
                totalTests++;

                log(`\n[Text Test ${i + 1}/${testCases.length}] ${testCase.name}`, 'test');

                try {
                    // Export
                    const base64String = simulateExportConfigText(
                        testCase.config,
                        testCase.metadata.creator,
                        testCase.metadata.description
                    );

                    // Import
                    const imported = simulateImportConfigText(base64String);

                    // Compare
                    const configMismatches = compareConfigs(testCase.config, imported.config);
                    const metadataMismatches = compareConfigs(testCase.metadata, imported.metadata);
                    const allMismatches = [...configMismatches, ...metadataMismatches];

                    if (allMismatches.length === 0) {
                        log(`  âœ“ PASSED: All values preserved`, 'success');
                        passedTests++;
                    } else {
                        log(`  âœ— FAILED: Mismatches detected:`, 'error');
                        allMismatches.forEach(mismatch => {
                            log(`    - ${mismatch.field}: "${mismatch.original}" â†’ "${mismatch.imported}"`, 'error');
                        });
                        failedTests++;
                    }

                } catch (error) {
                    log(`  âœ— FAILED: Exception: ${error.message}`, 'error');
                    failedTests++;
                }

                updateSummary(totalTests, passedTests, failedTests);
                await delay(100);
            }

            // Test all terrain types
            log('\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€', 'header');
            log('ALL TERRAIN TYPES TEST', 'header');
            log('â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€', 'header');

            for (let i = 0; i < terrainTypes.length; i++) {
                const terrain = terrainTypes[i];
                totalTests++;

                log(`\n[Terrain Test ${i + 1}/${terrainTypes.length}] ${terrain}`, 'test');

                try {
                    const testConfig = {
                        size: 1024,
                        terrainType: terrain,
                        playerCount: 4,
                        noiseStrength: 0.5,
                        heightVariation: 0.6,
                        waterLevel: 0.3,
                        metalSpots: 50,
                        metalStrength: 0.7,
                        geoSpots: 10,
                        startPositions: []
                    };

                    const jsonString = simulateExportConfigJSON(testConfig, 'Tester', `Testing ${terrain}`);
                    const imported = simulateImportConfigJSON(jsonString);

                    if (imported.config.terrainType === terrain) {
                        log(`  âœ“ PASSED: Terrain type "${terrain}" preserved`, 'success');
                        passedTests++;
                    } else {
                        log(`  âœ— FAILED: Terrain type mismatch`, 'error');
                        failedTests++;
                    }

                } catch (error) {
                    log(`  âœ— FAILED: Exception: ${error.message}`, 'error');
                    failedTests++;
                }

                updateSummary(totalTests, passedTests, failedTests);
                await delay(100);
            }

            // Test all map sizes
            log('\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€', 'header');
            log('ALL MAP SIZES TEST', 'header');
            log('â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€', 'header');

            for (let i = 0; i < mapSizes.length; i++) {
                const size = mapSizes[i];
                totalTests++;

                log(`\n[Size Test ${i + 1}/${mapSizes.length}] ${size}x${size}`, 'test');

                try {
                    const testConfig = {
                        size: size,
                        terrainType: 'continental',
                        playerCount: 4,
                        noiseStrength: 0.5,
                        heightVariation: 0.6,
                        waterLevel: 0.3,
                        metalSpots: 50,
                        metalStrength: 0.7,
                        geoSpots: 10,
                        startPositions: []
                    };

                    const jsonString = simulateExportConfigJSON(testConfig, 'Tester', `Testing ${size}x${size}`);
                    const imported = simulateImportConfigJSON(jsonString);

                    if (imported.config.size === size) {
                        log(`  âœ“ PASSED: Map size "${size}" preserved`, 'success');
                        passedTests++;
                    } else {
                        log(`  âœ— FAILED: Map size mismatch`, 'error');
                        failedTests++;
                    }

                } catch (error) {
                    log(`  âœ— FAILED: Exception: ${error.message}`, 'error');
                    failedTests++;
                }

                updateSummary(totalTests, passedTests, failedTests);
                await delay(100);
            }

            // Cross-format test
            log('\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€', 'header');
            log('CROSS-FORMAT TEST', 'header');
            log('â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€', 'header');

            totalTests++;
            log('\n[Cross-Format Test] JSON export â†’ Text import', 'test');

            try {
                const testConfig = {
                    size: 1024,
                    terrainType: 'islands',
                    playerCount: 6,
                    noiseStrength: 0.75,
                    heightVariation: 0.8,
                    waterLevel: 0.5,
                    metalSpots: 75,
                    metalStrength: 0.9,
                    geoSpots: 25,
                    startPositions: []
                };

                const jsonString = simulateExportConfigJSON(testConfig, 'Cross Tester', 'Cross-format test');
                const base64String = btoa(jsonString);
                const imported = simulateImportConfigText(base64String);

                const configMismatches = compareConfigs(testConfig, imported.config);
                const metadataMismatches = compareConfigs({creator: 'Cross Tester', description: 'Cross-format test'}, imported.metadata);
                const allMismatches = [...configMismatches, ...metadataMismatches];

                if (allMismatches.length === 0) {
                    log(`  âœ“ PASSED: Cross-format conversion preserves data`, 'success');
                    passedTests++;
                } else {
                    log(`  âœ— FAILED: Cross-format mismatches detected`, 'error');
                    failedTests++;
                }

            } catch (error) {
                log(`  âœ— FAILED: Exception: ${error.message}`, 'error');
                failedTests++;
            }

            updateSummary(totalTests, passedTests, failedTests);

            // Final summary
            log('\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', 'header');
            log('FINAL RESULTS', 'header');
            log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', 'header');
            log(`\nTotal Tests: ${totalTests}`);
            log(`Passed: ${passedTests}`, 'success');
            log(`Failed: ${failedTests}`, failedTests > 0 ? 'error' : 'success');
            log(`Pass Rate: ${((passedTests / totalTests) * 100).toFixed(1)}%`);

            if (failedTests === 0) {
                log('\nâœ“ ALL TESTS PASSED - Round-trip workflow is working correctly!', 'success');
                log('The export/import functions preserve all configuration data accurately.', 'success');
            } else {
                log('\nâœ— SOME TESTS FAILED - Please review the failures above.', 'error');
            }

            log('\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n', 'header');

            document.getElementById('runButton').disabled = false;
            updateSummary(totalTests, passedTests, failedTests);
        }

        function updateSummary(total, passed, failed) {
            const summary = document.getElementById('summary');
            summary.style.display = 'block';

            document.getElementById('totalTests').textContent = total;
            document.getElementById('passedTests').textContent = passed;
            document.getElementById('failedTests').textContent = failed;

            const passRate = total > 0 ? ((passed / total) * 100).toFixed(1) : 0;
            document.getElementById('passRate').textContent = passRate + '%';

            const progressFill = document.getElementById('progressFill');
            progressFill.style.width = passRate + '%';
            progressFill.textContent = passRate + '%';

            const overallStatus = document.getElementById('overallStatus');
            if (total === 0) {
                overallStatus.textContent = 'Pending';
                overallStatus.className = 'info';
            } else if (failed === 0) {
                overallStatus.textContent = 'âœ“ ALL PASSED';
                overallStatus.className = 'success';
            } else {
                overallStatus.textContent = 'âœ— SOME FAILED';
                overallStatus.className = 'failure';
            }
        }
    </script>
</body>
</html>
